:stylesheet: daro-dark.css
:toc: left
:toclevels: 4
:toc-title: Lógica computacional
:imagesdir: ./images
:stem: 

= LÓGICA

== Semana 1

=== Argumento 

Un argumento es una secuencia de enunciados destinados a demostrar la verdad de una frase. 

=== Partes de argumento

La frase al final de la secuencia se llama la conclusión y los enunciados anteriores se llaman premisas
Para tener confianza en la conclusión que obtiene de un argumento, debe asegurarse de que las premisas sean aceptables por sus propios méritos o que son consecuencia de otros enunciados que se sabe que son verdaderos.

En lógica, la forma de un argumento se distingue de su contenido. El análisis lógico no le ayudará a determinar el valor intrínseco del contenido de un argumento, pero le ayudará a analizar la forma de un argumento para determinar si la verdad de la conclusión se desprende necesariamente de la verdad de las premisas. Por esta razón, la lógica a veces se define como la ciencia de la inferencia necesaria o la ciencia del razonamiento.

En lógica, la forma de un argumento se distingue de su contenido. El análisis lógico no le ayudará a determinar el valor intrínseco del contenido de un argumento, pero le ayudará a analizar la forma de un argumento para determinar si la verdad de la conclusión se desprende necesariamente de la verdad de las premisas. Por esta razón, la lógica a veces se define como la ciencia de la inferencia necesaria o la ciencia del razonamiento.

=== Lógica formas vs informal

La mayoría de las definiciones de la lógica formal se han desarrollado de acuerdo con la lógica natural o intuitiva utilizada por personas que han sido educadas para pensar con claridad y utilizar el lenguaje con cuidado. Las diferencias que existen entre la lógica formal e intuitiva son necesarias para evitar la ambigüedad y obtener consistencia. En cualquier teoría matemática, se definen nuevos términos usando los que se han definido previamente. Sin embargo, este proceso tiene que comenzar en alguna parte. Unos pocos términos iniciales permanecen necesariamente indefinidos. En lógica, las palabras, enunciado, verdadero y falso son términos iniciales indefinidos.

=== Enunciado

Es una frase que es verdadera o falsa, pero no ambas

* 2 + 2 = 4, o 2 + 2 = 3: ambos son enunciados. La 1 es verdadera, la 2 es falsa. Pero ambas son frases que puede tienen como resultado v o f
* x + y > 0 no es un enunciado porque para algunos valores de x e y es verdadero, para otros es falso, pero por si solo no se lo puede tomar como un enunciado


=== Enunciados compuestos

|===
| ~ | no | negación
| ^ |  y | conjunción
| v |  o | disyunción
|===

* ~ tiene precedencia
* ^ y v son iguales => p ^ q v r no es un enunciado válido por ser ambiguo. Para dejar de serlo tiene que tener ()

* pero = y: se utiliza la palabra *pero* cuando el resto de la frase es inesperada. Juan mide 1.90 pero no es pesado
* ni ni  = no p y no q

* p pero q = p y q
* ni p ni q = ~p y ~q

=== Y, O y desigualdades

====
 x <= a es x<a o x=a
 a <= x <= b es a<=x y x<=b
====


=== Valores de Verdad

* Negación: si p es un enunciado variable, la negación de p es "no p"
|===
|p|~p
|v|f
|f|v
|===

* Conjunción: "p y q"  es V solo cuando p=v y q=v
|===
|p|q|p^q
|v|v|v
|v|f|f
|f|v|f
|f|f|f
|===

* Disyunción: "p y q" es verdadero cuando p es V o q es V o ambas son V. Es falsa cuando ambas son F

|===
|p|q|p v q
|v|v| v
|v|f| v
|f|v| v
|f|f| f
|===


=== Equivalencias logicas

Dos formas de enunciado son logicamente equivalentes si y solo si tienen los mismos valores de verdad para cada posible situacion 


== Semana 2

=== Negaciones de Y y O: Leyes de De Morgan

La negación de un enunciado "y" es lógicamente equivalente al enunciado "o" en el que cada componente es negado. 
 ~ (p ^ q) es ~p v ~q
La negación de un enunciado o es lógicamente equivalente al enunciado y en el que cada componente es negado. 
 ~ (p v q) es ~p ^ ~q

Nota: "ni p ni q" significa to mismo que "~p y ~q"

===  Desigualdades y Leyes de De Morgan

-1 < x <=4

se puede descomponer en -1<x Y x<=4

Su negacion es -1</x (-1 no es menor que x) Y x<=/4 x no es menor o igual que 4
Se puede interpretar como -1>x O x>=4

=== Tautologías y contradicciones

* Tautologia: es una forma de enunciado que siempre es verdadera, independientemente de los valores de verdad de los enunciados individuales sustituidos por sus enunciados variables. 
* Una contradicción es una forma de enunciado que siempre es falso, independientemente de los valores de verdad de los enunciados individuales de los enunciados variables sustituidos. 

=== Resumen Equivalencias lógicas

p, q y r son variables
t es una tautología
c es una contradicción


==== simbolos

|===
|  | Descripción                    |                                   |
| 1| Leyes conmutativas             | p ∧ q ≡ q ∧ p                     | p V q ≡ q V p
| 2| Ley asociativa                 | (p ∧ q) ∧ r ≡ p ∧ (q ∧ r)         | (p V q) V r ≡ p V (q V r)
| 3| Ley distributiva               | p ∧ (q V r) ≡ (p ∧ q) V (p ∧ r)   | p V (q ∧ r) ≡ (p V q) ∧ (p V r)
| 4| Ley de identidad               | p ∧ t ≡ p                         | p V c ≡ p
| 5| Ley de negación                | p V ~p ≡ t                        | p ∧ ~p ≡ c
| 6| Ley doble negación             | ~ (~p) ≡ p                         |
| 7| Leyes de idempotencia          | p ∧ p ≡ p                         | p V p ≡ p
| 8| Ley universal acotada          | p V t ≡ t                         | p ∧ c ≡ c
| 9| Ley de morgan                  | ~(p ∧ q) ≡ ~p V ~q                | ~(p V q) ≡ ~p ∧ ~q
|10| Ley de absorción               | p V (p ∧ q) ≡ p                   | p ∧ (p V q) ≡ p
|11| Negaciones de t y c            | ~t ≡ c                            | ~c ≡ t
|12| NAND (SHEFFER)                 | P \| Q ≡ ~ (P ∧ Q)                 |
|13| NOR (PEIRCE)                   | P ↓ Q ≡ ~ (P V Q)                 |

|===

==== con and/or/not

|===
|  | Descripción                    |                                           |
| 1| Leyes conmutativas             | p AND q ≡ q AND p                         | p OR q ≡ q OR p
| 2| Ley asociativa                 | (p AND q) AND r ≡ p AND (q AND r)         | (p OR q) OR r ≡ p OR (q OR r)
| 3| Ley distributiva               | p AND (q OR r) ≡ (p AND q) OR (p AND r)   | p OR (q AND r) ≡ (p OR q) AND (p OR r)
| 4| Ley de identidad               | p AND t ≡ p                               | p OR c ≡ p
| 5| Ley de negación                | p OR NOT p ≡ t                            | p AND NOT p ≡ c
| 6| Ley doble negación             | NOT (NOT p) ≡ p                           |
| 7| Leyes de idempotencia          | p AND p ≡ p                               | p OR p ≡ p
| 8| Ley universal acotada          | p OR t ≡ t                                | p AND c ≡ c
| 9| Ley de morgan                  | NOT (p AND q) ≡ NOT p OR NOT q            | NOT (p OR q) ≡ NOT p AND NOT q
|10| Ley de absorción               | p OR (p AND q) ≡ p                        | p AND (p OR q) ≡ p
|11| Negaciones de t y c            | NOT t ≡ c                                 | NOT c ≡ t
|12| NAND (SHEFFER)                 | P NAND Q ≡ ~ (P ∧ Q)                 |
|13| NOR (PEIRCE)                   | P NOR Q ≡ ~ (P V Q)                 |
|===

==== con + . Ā 1 0

Ā
Ē
Ẽ̄

|===
|  | Descripción                    |                                           |
| 1| Leyes conmutativas             | A.E=E.A                                   | A+E=E+A
| 2| Ley asociativa                 | (A.E).O=A.(E.O)                           | (A+E)+O=A+(E+O)
| 3| Ley distributiva               | A.(E+O)=(A.E)+(A.O)                       | A+(E.O)=(A+E).(A+O)
| 4| Ley de identidad               | A.1=A                                     | A+0=A
| 5| Ley de negación                | A.Ā=0                                     | A+Ā≡1
| 6| Ley doble negación             | Ẽ̄=E tambien \~(~E)=E                      |
| 7| Leyes de idempotencia          | A.A=A                                     | A+A=A
| 8| Ley universal acotada          | A+1=1                                     | A.0=0
| 9| Ley de morgan                  | ~(A.E)=Ā+Ē                                | ~(A+E)=Ā.Ē
|10| Ley de absorción               | A+(A.E) ≡ A                               | A.(A+E)=A
|11| Negaciones de t y c            | ~1=0                                      | ~0=1
|12| NAND (SHEFFER)                 | P NAND Q ≡ ~ (P ∧ Q)                      |
|13| NOR (PEIRCE)                   | P NOR Q ≡ ~ (P V Q)                       |
|===

== Semana 3

=== Circuitos lógicos

* Interruptores en serie

image::2023-08-29T12-03-42-284Z.png[] 

|===
| INTER     | RUPTORES  | FOCO
|  P        | Q         | ESTADO
|cerrado    |cerrado    | encendido
|cerrado    |abierto    | apagado
|abierto    |cerrado    | apagado
|abierto    |abierto    | apagado
|===

* Interruptores en paralelo

image::2023-08-29T12-05-19-336Z.png[] 

|===
| INTER     | RUPTORES  | FOCO
|  P        | Q         | ESTADO
|cerrado    |cerrado    | encendido
|cerrado    |abierto    | encendido
|abierto    |cerrado    | encendido
|abierto    |abierto    | apagado
|===

Cambiando abierto y encendido por V y cerrado y apagado por F se obtienen las tablas de verdad 

En serie es tabla de verdad Y
En paralelo es tabla de verdad O


=== Cajas Negras y Puertas

Las cajas negras son implementaciones de circuitos lógicos, donde su implementación no importa. La atención se centra entre las entradas y sus salidas

image:2023-08-29T21-08-00-483Z.png[] 


=== Expresión booleana correspondiente a un circuito

En lógica, variables tales como p, q y r representan enunciados y un enunciado puede toner uno de los dos valores de verdad: V (verdadero) o F (falso)

Cualquier variable, tal como un enunciado variable o una señal de entrada que puede tomar uno de los dos valores, se llama una variable booleana.

Una expresión compuesta de variables booleanas y conectores ~ ∧ v se denomina una expresión booleana

=== Reconocedor 

es un circuito que genera un I pars exactamente una combinación particular de señales de entrada y salidas 0 pars las demás combinaciones. 

image::2023-08-29T21-45-19-131Z.png[] 


=== Puerta and de entrada multiple

 ((p ∧ q) ∧ (R ∧ S)) ∧ T se grafica 

image::2023-08-29T22-53-13-138Z.png[] 

Luego por propiedad asociativa 

 ((p ∧ q) ∧ (R ∧ S)) ∧ T = (p ∧ (q ∧ R)) ∧ (S ∧ T)

 (p ∧ (q ∧ R)) ∧ (S ∧ T)

image::2023-08-29T22-55-12-342Z.png[] 

Cada uno de los circuitos en las figures 2.4.4 y 2.4.5 es, por tanto. una implementation de la expresien P ∧ Q ∧ R ∧ S ∧ T. Este circuito recibe el nombre de *puerta AND de entrada multiple* y se representa por el diagrama que se muestra en la figura 2 4 6 Las puertas OR de entrada multiple se construyen de manera similar. 

image::2023-08-29T22-57-21-670Z.png[] 

=== Diseño de un circuito para una tabla dada de entrada/salida

Diseñar un circuito lógico para la siguiente tabla de entrada

image:2023-08-29T23-05-46-350Z.png[] 

. Identificar cada renglón para el que la salida es 1, en este caso el primero, tercero y cuarto renglón
. Para cada uno de estos renglones construir una expresión y que produzca un 1  para la combinación exacta de valores de entrada para ese renglón y un 0 para todas las otras combinaciones de los valores de entrada.
.. La expresión para el primer renglón es P ∧ Q ∧ R porque  P ∧ Q ∧ R es 1 si P = 1 y Q = 1 y R = 1 y es 0 pars todos los demás valores de P, Q y R.
.. La expresión para el tercer renglón es P ∧ ~Q ∧ R porque  P ∧ ~Q ∧ R es 1 si P = 1 y Q = 0 y R = 1 y es 0 pars todos los demás valores de P, Q y R.
.. La expresión para el cuarto renglón es P ∧ ~Q ∧ ~R porque  P ∧ ~Q ∧ ~R es 1 si P = 1 y Q = 0 y R = 0 y es 0 pars todos los demás valores de P, Q y R.
. Ahora, cualquier expresión booleana con la tabla dada como su tabla de verdad tiene el valor 1 en el caso P ∧ Q ∧ R = 1, o en caso de P ∧ ~Q ∧ R, o en caso de P ∧ ~Q ∧ ~R  en ningún otro caso. De lo que se deduce que una expresión booleana con la labia de verdad dada es 

 (P ∧ Q ∧ R) V (P ∧ ~Q ∧ R) V (P ∧ ~Q ∧ ~R)       expresión 2.4.5

image::2023-08-29T23-16-55-882Z.png[] 

Observar que la expresión (2.4.5) es una disyunción de términos en los que ellos mismos son conjunciones en los que una de P o ~P, una de Q o ~Q y de una de R o ~R todas aparecen. Se dice que tales expresiones están en *forma normal disyuntiva* o en *forma de suma de productos*. 

=== Equivalencias de circuitos logicos

Dos circuitos lógicos son equivalentes entre si si sus tablas de verdades son idénticas

=== Puertas NAND y NOR

Una puerta NAND es una sola puerta que actila como una puerta AND seguida de una puerta NOT.  Así, la señal de salida de la puerta NAND es 0 cuando y solo cuando, ambas senates de entrada son 1

image::2023-08-30T00-39-04-089Z.png[] 

Una puerta NOR actúa como una puerta OR seguida de una puerta NOT. La señal de salida pars una puerta NOR es 1 cuando y solo cuando, ambas entradas son 0.

image::2023-08-30T00-40-32-868Z.png[] 


== Semana 4

=== Simplificación mediante álgebra de Boole

Una expresión booleana simplificada emplea el menor número posible de puertas en la implementación de una determinada expresión.

Ejemplo:

Simplificar AB + A(B + C) + B(B + C)

. Por ley distributiva: AB + AB + AC + BB + BC
. Por ley de idempotencia: (AB + AB) = AB entonces AB + AC + BB + BC
. Por ley de idempotencia: B.B = B entonces AB + AC + B + BC
. Por ley de absorción B + BC = B entonces AB + AC + B
. Por conmutacion de suma logica B + AB +  AC
. Por ley de absorción B + AB = B entonces *B + AC*

 Estos dos circuitos de puertas son equivalentes, es decir, para cualquier combinación de valores en las entradas A, B y C, obtenemos siempre la misma salida en ambos circuitos.

image::2023-09-04T00-38-39-808Z.png[] 

=== Formas estándar de expresiones booleanas

Todas las expresiones booleanas, independientemente de su forma, pueden convertirse en cualquiera de las dos formas estándar: suma de productos o producto de sumas. La estandarización posibilita que la evaluación, simplificación e implementación de las expresiones booleanas sea mucho más sistemática y sencilla.

=== Suma de productos

Cuando dos o más productos se suman mediante la adición booleana, la expresión resultante se denomina suma de productos (SOP, Sum Of Products). Una suma de productos puede contener también términos de una única variable.

=== Forma estándar de la suma de productos

Es aquella en la que todas las variables de la función aparecen en cada uno de los términos de la expresión

La expresión suma de productos estándar es importante en la construcción de tablas de verdad, y en el método de simplificación de los mapas de Karnaugh

Cualquier expresión suma de productos no estándar (que denominaremos simplemente suma de productos) puede convertirse al formato estándar utilizando el álgebra de Boole.

Cada término producto de una suma de productos que no contenga todas las variables de la función puede ampliase a su forma estándar de manera que incluya todas las variables del dominio y sus complementos. Como se muestra en los siguientes pasos, una suma de productos no estándar se convierte a su forma estándar utilizando el postulado básico de la suma, donde dice que la variable sumada a su complemento es igual a 1.

image:2023-09-04T01-06-42-980Z.png[] 

=== Productos de suma estandar

Un producto de sumas estándar es aquel en el que todas las variables del dominio o sus complementos aparecen en cada uno de los términos de la expresión.

Cualquier producto de sumas no estándar (que denominaremos simplemente producto de sumas) puede convertirse a su forma estándar mediante el álgebra de Boole. 

Cada término suma de una expresión producto de sumas que no contenga todas las variables del dominio puede extenderse para obtener su formato estándar incluyendo todas las variables del dominio y sus complementos. Como se establece en los pasos siguientes, un producto de sumas no estándar se convierte a su formato estándar utilizando la regla booleana que establece que una variable multiplicada por su complemento es igual a 0. 

image::2023-09-04T01-18-14-461Z.png[] 

=== Expresiones booleanas y sus tablas de verdad

Todas las expresiones booleanas pueden convertirse fácilmente en tablas de verdad utilizando los valores binarios de cada término de la expresión.

Para una expresión cuyo dominio es de dos variables, existen cuatro combinaciones distintas de estas variables (22 = 4). Para una expresión cuyo dominio tiene tres variables, existen ocho (23 = 8) combinaciones posibles de dichas variables. Para una expresión con un dominio de cuatro variables, existen dieciséis combinaciones diferentes de dichas variables (24 = 16), etc.


=== Conversión de suma de productos a tabla de verdad

. Enumerar todas las posibles combinaciones de los valores de las variables de la expresión. 
. Hay que pasar la suma de productos a su formato estándar, si no lo está ya. 
. Para completar la tabla debemos tener en cuenta que cuando la variable no está complementada, el valor será 1, mientras que, si se encuentra complementada, es decir negada, entonces el valor que adopta es 0.
. Por último, se escribe un 1 en la columna de salida (X) para cada valor binario que hace que la suma de productos estándar sea 1, y se escribe un 0 para los restantes valores.

Ejemplo:

image::2023-09-04T01-31-48-516Z.png[]

=== Conversión de un producto de sumas a tabla de verdad

. Enumerar todas las posibles combinaciones de valores binarios de las variables del mismo modo que se hace para una suma de productos. 
. Pasar el producto de sumas a su formato estándar, si no lo está ya. 
. Tener en cuenta que cuando la variable no está complementada, el valor será 0, mientras que, si se encuentra complementada, es decir negada, entonces el valor que adopta es 1.
. Se escribe un 0 en la columna de salida (X) para cada valor binario que hace que la suma de productos estándar sea 0, y se escribe un 1 para los restantes valores binarios. 


image::2023-09-04T01-35-51-835Z.png[] 


=== Mapas de Karnaugh

El número de celdas de un mapa de Karnaugh es igual al número total de posibles combinaciones de las variables de entrada, al igual que el número de filas de una tabla de verdad. Para tres variables, el número de celdas necesarias es de 2^3 = 8. Para cuatro variables, el número de celdas es de 2^4 = 16.

*El mapa de Karnaugh de tres variables es una matriz de ocho celdas.*

image::2023-09-04T23-42-28-208Z.png[] 

*Mapas de Karnaugh de cuatro variables*

image::2023-09-04T23-43-03-880Z.png[] 


=== Adyacencia de celdas

Las celdas de un mapa de Karnaugh se disponen de manera que sólo cambia una única variable entre celdas adyacentes. La adyacencia se define por un cambio de una única variable. Las celdas que difieren en una única variable son adyacentes. Por ejemplo, en el mapa de tres variables, la celda 010 es adyacente a las celdas 000, 011 y 110. La celda 010 no es adyacente a la celda 001, ni a la celda 111, ni a la celda 100 ni a la celda 101.

Físicamente, cada celda es adyacente a las celdas que están situadas inmediatas a ella por cualquiera de sus cuatro lados. Un celda no es adyacente a aquellas celdas que tocan diagonalmente alguna de sus esquinas. Además, las celdas de la fila superior son adyacentes a las de la fila inferior y las celdas de la columna izquierda son adyacentes a las situadas en la columna de la derecha. Esto se denomina adyacencia cíclica, ya que podemos pensar que el mapa de Karnaugh se dobla de forma que se toquen los extremos superior e inferior como si fuera un cilindro o los extremos de la derecha e izquierda para formar la misma figura. 

El siguiente mapa de Karnaugh ilustra la adyacencia de celdas en un mapa de cuatro variables, aunque se aplican las mismas reglas de adyacencia a los mapas de Karnaugh con cualquier número de celdas.

image:2023-09-04T23-46-02-455Z.png[] 


=== Simplificación de una suma de productos mediante el mapa de Karnaugh

* Construir tabla de 2 o 3 variables. Por la adyacencia, la secuencia de combinación de 2 variables es 00 01 11 10

3 Variables

|===
|A B \ C| 0 | 1
|0 0    |   |
|0 1    |   |
|1 1    |   |
|1 0    |   |
|===

4 Variables

|===
|A B \ C D  | 0 0   | 0 1   |  1 0  |  1  1
|0 0        |       |       |       |       
|0 1        |       |       |       |       
|1 1        |       |       |       |       
|1 0        |       |       |       |       
|===

* Por cada término de la expresión suma de productos, se coloca un 1 en el mapa de Karnaugh en la celda correspondiente al valor del producto

image:2023-09-06T11-43-16-518Z.png[] 

* Agrupación de unos

.. Un grupo tiene que contener 1, 2, 4, 8 ó 16 celdas
.. Cada celda de un grupo tiene que ser adyacente a una o más celdas del mismo grupo
.. Incluir siempre en cada grupo el mayor número posible de 1s de acuerdo a la regla número 1
.. Cada 1 del mapa tiene que estar incluido en al menos un grupo. Los 1s que ya pertenezcan a un grupo pueden estar incluidos en otro, siempre que los grupos que se solapen contengan 1s no comunes.

image:2023-09-06T11-45-44-609Z.png[] 

* Cada grupo de celdas que contiene 1s da lugar a un término producto compuesto por todas las variables que aparecen en el grupo en sólo una forma (no complementada o complementada). Las variables que aparecen complementadas y sin complementar dentro del mismo grupo se eliminan. A éstas se les denomina variables contradictorias.

image:2023-09-06T11-47-06-725Z.png[] 

* Cuando se han obtenido todos los términos producto mínimos a partir del mapa de Karnaugh, se suman para obtener la expresión suma de productos mínima.

image:2023-09-06T11-47-23-133Z.png[] 


=== Simplificación mediante el mapa de Karnaugh de expresiones producto de sumas

* LLevar todo a producto de suma estandar

* Construir tabla de 2 o 3 variables igual que en suma de productos
* Los valores negados valen 1, los valores no negados valen 0
* Segun los valores de cada termino, colocarlos en la tabla de karnough, peor en vez de 1, colocar 0

image::2023-09-06T23-20-01-939Z.png[] 

* Deducir agrupas los ceros adyacentes. Se pueden agrupar 1,2,4,8,16 ceros
* Por cada grupo de ceros deducir la variable. Esto se hace viendo en todo el grupo, cuales son las variables que cambian de estado. Si cambia de estado de un cero a otro, la variable se descarta. Si permanece con el mismo estado, la variable no se descarta y forma parte del termino, sumando las variables

image::2023-09-06T23-23-45-436Z.png[] 

Tambien se pueden tomar los 1 como suma de productos, y se obtiene la misma ecuación si se aplica la propiedad distributiva


image::2023-09-06T23-24-38-529Z.png[] 

== Semana 7 Sistemas de Numeración

=== Sistema decimal

La notación decimal se basa en el hecho de que cualquier número entero positivo puede ser escrito de manera única como una suma de productos de la forma stem:[d.10^n] donde cada n es un entero no negativo y cada d es uno de los dígitos decimales de 0, 1, 2, 3, 4, 5, 6, 7, 8, o 9.

La notación decimal (o de base 10) expresa un número como una cadena de dígitos en la que cada dígito indica la posición de la potencia de 10 por la que se multiplica.

Ejemplo: 

stem:[5049 = 5 . 10^3  + 0 . 10^2 + 4 . 10^1 + 9 . 10^0 ]

image::2023-10-04T22-52-59-655Z.png[]

La raíz latina deci significa “diez”.

=== Sistema binario: Notaciones

* 2b10 = significa 2 en base 10 (sistema decimal)
* 1b2 = significa 1 en base 2 (sistema binario)
* 2^4 = significa 2 elevado a la 4 ó 2 potencia de 4
* BSS() = binario sin signo (esto significa que de momento, sólo veremos número NO NEGATIVOS)

=== Representación binaria

La raíz latina bi significa “dos”.


Cualquier número entero se puede representar como una suma única de productos de la forma d.2^n donde cada n es un entero y cada d es uno de los dígitos binarios (o bits) 0 o 1. Por ejemplo,  

image:2023-10-04T23-46-07-660Z.png[] 

En notación binaria, como en notación decimal, se escriben sólo los dígitos binarios y no las potencias de la base. En notación binaria, entonces


image:2023-10-04T23-46-31-354Z.png[] 

donde los subíndices indican la base, ya sea 10 o 2, en el que está escrito el número. Los lugares en notación binaria corresponden con las distintas potencias de 2. La posición más a la derecha es el lugar de los unos (o lugar 2^0), a la izquierda está el lugar de los dos (o lugar 2^1), a la izquierda está el lugar de los cuatro (o lugar 2^2) y así sucesivamente, como se muestra a continuación.

image:2023-10-04T23-47-10-886Z.png[] 

Al igual que en la notación decimal, se puede agregar o quitar ceros a la izquierda al gusto. Por ejemplo,

image:2023-10-04T23-47-44-094Z.png[] 

=== Conversion de un binario a decimal    

image:2023-10-05T00-54-04-977Z.png[] 

=== Conversión de un decimal a binario

1. Si x > 0 calcular la división entera: x/2,

2. Tomar el resto de la división anterior como un bit (pues es un valor en el conjunto {0,1})

3. Si el cociente es mayor a cero, volver al paso 1 con el cociente como dividendo.

4. Se construye la cadena tomando solo los restos: en el orden que fueron obtenidos se ubican de derecha a izquierda (menos significativo a más significativo).

Suponer por ejemplo que se necesita representar el número 26 en el sistema binario:

1. Se divide el valor 26 por 2 obteniendo resto 0 y cociente 13

2. El resto 0 es el bit menos significativo

3. El nuevo valor de x es 13. Se calcula x=2 obteniendo resto 1 y cociente 6.

4. El resto 1 es el segundo bit de la cadena

5. El nuevo valor de x es 6. Se calcula 6=2 obteniendo resto 0 y cociente 3.

6. El resto 0 es el tercer bit de la cadena

7. El nuevo valor de x es 3. Se calcula 3=2 obteniendo resto 1 y cociente 1.

8. El resto 1 es el cuarto bit de la cadena

9. El nuevo valor de x es 1. Se calcula 1=2 obteniendo resto 1 y cociente 0.

10. El resto 1 es el quinto bit de la cadena

11. Se construye la cadena tomando solo los restos, en el orden que fueron obtenidos, de derecha a izquierda: 11010

El proceso anterior se aprecia gráficamente de la siguiente manera: 

image:2023-10-05T00-56-05-544Z.png[] 

=== Rango del sistema

Considerar por ejemplo un sistema binario restringido a 3 bits y que sólo contemple los números Naturales, lo llamamos Sin Signo y lo denotamos BSS(3).

Para analizar su rango se debe determinar el valor mínimo y máximo representables. Para el primer caso se interpreta la primer cadena: 000:

stem:[(000) = 0.2^2+0.2^1+0.2^0 = 0]

Para el segundo caso se interpreta la última cadena: 111

stem:[(111) = 1.2^2+1.2^1+1.2^0 = 7]

Es decir que el rango de BSS(3) son todos los números naturales comprendidos entre 0 y 7, y se representa de la siguiente manera: [0;7]. El conjunto de valores representables tiene 8 elementos.

Además, con 3 bits se pueden construir 8 cadenas de números representables, es decir, 2^3 = 8. 

Generalizando

====
En un sistema BSS(n) se tiene 2^n cadenas y un rango [0; 2n - 1]
====

Una lista de potencias de 2 es útil para hacer conversiones de binario a decimal y de decimal a binario

image::2023-10-05T01-01-31-647Z.png[] 

=== Suma en notación binaria

Sume 1101b2 y 111b2 usando notación binaria.

Ya que 2b10 = 10b2 y 1b10 = 1b2, la traducción de 1b10 + 1b10 = 2b10 en notación binaria es 

image::2023-10-05T01-03-17-295Z.png[] 

De lo que se deduce que la suma de dos 1 juntos, da como resultado llevar un 1 cuando se usa la notación binaria. Sumar tres 1 juntos, también da como resultado en llevar un 1 ya que 3b10 = 11b2 (“uno uno base dos”)

image::2023-10-05T01-03-57-797Z.png[] 

Así, la suma se puede realizar de la siguiente manera:

image::2023-10-05T01-04-14-545Z.png[] 

=== Resta en notación binaria

aca lo entendí: https://youtu.be/d1TwfFDfrmg?t=319

Reste 10112 de 110002 usando notación binaria 

En la resta decimal el hecho de que 10b10 - 1b10 = 9b10 se usa para prestar a través de varias columnas. Por ejemplo, considere lo siguiente: 

image::2023-10-05T01-04-56-592Z.png[] 

En la resta binaria, también puede ser necesario pedir prestado a través de más de una columna. Pero cuando usted pide prestado un 1b2 de 10b2, lo que queda es 1b2. 

image::2023-10-05T01-05-14-207Z.png[] 

Así, la resta se puede realizar de la siguiente manera:

image::2023-10-05T01-11-20-178Z.png[] 


=== Convirtiendo de notación hexadecimal a decimal

stem:[I(A3F_16) = 10 . 16^2 + 3 . 16^1 + 15 . 16^0 = 2623_10]

=== De hexadecimal a binario

Siguiendo la lógica del sistema binario, para representar valores mediante cadenas se deben realizar sucesivas divisiones por la base, que en este caso es 16, hasta obtener un cociente igual a 0 tomando cada resto como bits de la cadena. 


Ejemplo: Se necesita representar el número 26 en hexadecimal:

1. Se divide el valor 26 por 16 hasta encontrar un cociente 0

2. Se construye la cadena tomando solo los restos, empezando por el último

image::2023-10-05T01-32-43-951Z.png[] 

Uno de los restos es 10, entonces debemos traducirlo a la letra correspondiente aplicando la tabla de interpretación de hexadecimal. El valor 10 es equivalente a la letra A, quedando entonces 1A. Esto quiere decir que el valor 26 en decimal se corresponde con la cadena 1A en hexadecimal.


=== Rango del sistema

De la misma manera que en el sistema binario debemos calcular el mínimo número representable interpretando la cadena más chica y la más grande. Siendo el rango todos los números comprendidos entre ambos. Supongamos el sistema hexadecimal de 2 dígitos:

El mínimo valor representable es el resultado de interpretar la cadena 00, es decir:

stem:[0x16^1+0x16^0 = 0]

El máximo valor representable es el resultado de interpretar la cadena FF

stem:[15x16^1+15x16^0 = 255]

Por lo tanto el rango de este sistema es:  [0; 255]

=== Convirtiendo de binario a hexadecimal

La cadena binaria se segmenta formando cuartetos de bits comenzando por el bit menos significativo (b0)

1001011010100101 -> 1001 0110 1010 0101

Dado que cada cuarteto es alguna de las combinaciones de 4 bits del sistema BSS(4) y por lo tanto el rango que cubren es [0;15]

Considerando que dichos valores del rango se pueden representar por un solo caracter hexadecimal, entonces se aplica la siguiente tabla para convertir, uno a uno, los cuartetos de la cadena. 

|===
| Binario   | Hexa

| 0000      | 0
| 0001      | 1
| 0010      | 2
| 0011      | 3
| 0100      | 4
| 0101      | 5
| 0110      | 6
| 0111      | 7
| 1000      | 8
| 1001      | 9
| 1010      | A
| 1011      | B
| 1100      | C
| 1101      | D
| 1110      | E
| 1111      | F
|===


En el ejemplo mencionado:  

|===
|1001|0110|1010|0101
| 9  | 6  | A  | 5
|===

Por lo tanto, las cadenas 96A5 y 1001 0110 1010 0101 representan el mismo valor. Notar que no hizo falta obtener ese valor, dado que no se aplicó el proceso de interpretación. 

== Semana 8 Enteros Negativos en SM, CA1 y CA2

=== Signo Magnitud

Por convención se suele usar el primer bit de una cadena (aquel del extremo izquierdo) como indicador y se lo denomina bit de signo. Si el bit de signo es un 1 se trata de un número negativo, y en caso contrario es positivo. Los bits restantes de la cadena reciben el nombre de magnitud y su valor se determina con el mecanismo de interpretación del sistema binario sin signo (BSS).

Este sistema recibe el nombre Signo-Magnitud (SM).Cuando se restringe la cantidad de bits a n, se lo denota SM(n), donde el primer bit es el signo, y la magnitud es de n - 1 bits.

Ejemplo:  1010 = -2

==== Rango

stem:[\[-(2n-1 - 1); 2n-1 - 1\]]

en binario: [1111, 0111]

1111 es el nro mas grande (en valor abs) negativo
0111 es el nro mas grande (en valor abs) positivo

no hay stem:[2^n] números distintos como en BSS(n)

Ejemplo: n = 3, el rango del sistema SM es stem:[\[-(2^(3-1) - 1), 2^(3-1) \]] = [-3, 3] y en dicho intervalo hay 7 números: {-3; -2; -1; 0; 1; 2; 3}. En binario sin signo, con 3 bits se tenían 8 números. El numero que falta es 0 porque tiene doble representación: 000 y 100

===== Desventajas

. desaprovechar una cadena
. doble representación complica la aritmética (y los circuitos que la implementan) al tener que considerar dos cadenas que representan el mismo valor.  

===== Rango equilibrado

Esto significa que, partiendo desde el 0, se tienen n cantidad de números positivos y negativos

==== Suma

* La suma en SM considera diferentes casos en función de los signos de las cadenas a sumar. Si las cadenas a sumar tienen el mismo signo (ambas negativas o ambas positivas), la suma se realizará sumando las magnitudes y tomando como signo el signo del resultado.

[source]
----
Ejemplo 1101+1001

101 -> magnitud
001 -> magnitud
-----
110

signo=1 en ambos operandos -> signo = 1 -> 1101+1001=1110

----

[square]
* Si las cadenas a sumar tienen diferente signo
** Identificar qué cadena tiene la mayor magnitud (sea A la cadena de mayor magnitud y B la de menor magnitud). 
** El signo del resultado va a ser el signo que tenga A
** La magnitud resultado se obtiene restando la magnitud de B a la magnitud de A

[source]
----
1101 + 0001
Magnitudes 101 y 001. Magnitud mayor es 101 -> A 101 se resta 001 y el signo es 1 porque es el signo de la magnitud 101

 101
-001
 ---
 100

1101 + 0001 = 1100
----

==== Resta

C1 - C2 = C1 + (-C2)

Modificar el signo de C2 y luego sumarlos como indica la suma

=== Complemento a 1

El complemento a 1 de un número binario se obtiene al invertir todos los bits de ese número. Por ejemplo, el complemento a 1 de la secuencia binaria 0101 es 1010.

Se utiliza para representar el valor negativo de un número positivo

==== Ventajas 

* Representación de números negativos: El complemento a 1 permite la representación de números negativos en un sistema de números binarios con signo, lo que facilita la realización de operaciones aritméticas con números negativos.
* Eficiencia en operaciones aritméticas: El complemento a 1 permite realizar operaciones aritméticas, como la suma y la resta, de manera más eficiente y rápida en comparación con otros sistemas de representación de números negativos.
* Facilidad de implementación en hardware: El complemento a 1 es fácil de implementar en hardware, lo que lo hace adecuado para su uso en sistemas electrónicos y de computación.

==== Desventajas

* Dificultad en la comprensión: El complemento a 1 puede ser difícil de entender para aquellos que no están familiarizados con la teoría de números y la lógica binaria.
* Representación de números decimales: El complemento a 1 no es adecuado para la representación de números decimales, lo que limita su uso en aplicaciones que requieren una representación precisa de números decimales.
* Dificultad en la realización de operaciones de comparación: Las operaciones de comparación, como la igualdad y la mayoría, pueden ser más difíciles de realizar con números representados con complemento a 1.

==== Cálculo

. Invertir los bits

[source]
----
Ejemplo:  0101

1. Invertir los bits: 1010

1010 es el complemento a 1 de 0101

----

La suma del numero y su complemento dan 11111111



=== Complemento a 2


image::2023-10-13T16-43-38-333Z.png[] 



==== Cálculo

. Invertir los bits
. Añadir 1 al resultado

[source]
----
Ejemplo:  0101

1. Invertir los bits: 1010
2. Añadir 1: 0101+1 = 1011

1011 es el complemento a 1 de 0101

----

La suma del numero y su complemento dan 00000000

Si tengo 1 adelante, y tengo que saber cual es la magnitud (val absoluto) hago el complemento a 2

==== Interpretación

 * Se debe determinar si la cadena comienza con 0 (bn-1 = 0) o con 1 (bn-1 = 1). 
 ** Si bn-1 = 0, entonces se trata de un valor positivo, y en ese caso simplemente se interpreta como en un sistema binario sin signo (n). 
 ** En caso contrario, si bn-1 = 1, se sabe que representa un valor negativo, en cuyo caso se aplica la operación complemento() a la cadena, luego se interpretar el resultado en BSS(n) y finalmente se le agrega el signo negativo.


==== Rango

[-2n-1; 2n-1 - 1]

==== Aritmetica

La aritmética en CA2, por definición de complemento a la base, cumple con la propiedad de ser mecánicamente idéntica a la aritmética del sistema BSS. Es decir que tanto la suma como la resta se resuelven con los mismos circuitos de
suma (Full adder y restador). Suponer la siguiente operación de suma:     

== Semana 9 

=== Circuito semi-sumador

[stem]
++++

1_2 + 1_2 = 10_2 \
1_2 + 0_2 = 1_2 = 01_2 \
0_2 + 1_2 = 1_2 = 01_2 \
0_2 + 0_2 = 0_2 = 00_2 

++++

* Tiene 2 salidas: 
** una para el dígito binario de la izquierda (lleva) 
** uno para el dígito binario de la derecha (suma)

image:2023-10-16T14-52-09-301Z.png[] 

* suma: stem:[(P vv Q) ^^ ~(P ^^ Q)]
* lleva: stem:[P ^^ Q]


=== Sumador completo

Al considerar como construir un circuito que sume 2 números enteros binarios, nos encontramos con que en un punto se necesitan sumar 3 dígitos, 2 de la suma inicial y uno que es el que llevamos de la columna anterior. Por ejemplo :

image::2023-10-16T16-56-54-947Z.png[] 

en la segunda columna tenemos que sumar 3 dígitos binarios. Para ello hay que construir un circuito que calcule suma de 3 dígitos binarios, y esto es el *sumador completo*

[stem]
++++

" "P \
  +Q \
  +R \
-- \
CS 

++++

C=CARRY
S=SUMA


=== Sumador completo en base a un semi-sumador

Tener em cuenta: sumador completo tiene 3 entradas(2 dígitos + carry). Semi sumador tiene 2

Pasos de semi sumador para construir un sumador completo

==== Construcción

1) Sumar P y Q utilizando un semi sumador para obtener un número binario de dos dígitos

====
[stem]
++++

" "P \
+Q \
-- \
C_1S_1

++++
====

2) Sumar R a la suma stem:[C_1S_1" de "P y Q]

====
[stem]
++++

C_1S_1 \
+R \
--

++++
====

2a) Sumar R a stem:[S_1] utilizando un semisumador para obtener el número de dos dígitos stem:[C_2S]

====
[stem]
++++

" "S_1 \
+R \
-- \
C_2S
++++
====

 S es el dígito del extremo derecho de la suma total de P, Q y R.

2b) Determinar el dígito del extremo izquierdo, C

* Es imposible que tanto C1 como C2 sean 1. Si stem:[C_1=1] entonces P y Q son 1, así stem:[S_1=0]. Por lo tanto la suma stem:[S_1] y R da un número binario stem:[C_2S] donde stem:[C_2=0]
* C será un 1 en el caso de que 
** la suma de P y Q da como resultado llevar un 1 
** o en el caso de que la suma de S1 y R da como resultado llevar 1
** resumiendo los puntos anteriores C =1 si y sólo si, C1 = 1 o C2 = 1

==== Tabla y circuito

image:2023-10-16T19-47-17-314Z.png[] 

==== Circuito en paralelo

Dos sumadores completos y un semisumador se pueden utilizar juntos para construir un circuito que va a sumar dos números binarios de tres dígitos PQR y STU para obtener la suma W X Y Z. Esto se muestra en la figura que se encuentra debajo. Tal circuito se llama un sumador en paralelo. Los sumadores en paralelo pueden construirse para sumar números binarios de cualquier longitud finita.


image::2023-10-16T20-09-49-443Z.png[] 

ACLARACION: Si bien los circuitos tienen la denominación de "semisumador", cuando tienen tres entradas, son "sumadores completos".  En esta imagen del circuito, se los llama de esa manera a fin de dar a entender que "sumador completo" es el circuito compuesto por varios semisumadores. 


== Semana 10 

=== AND OR y XOR como habilitador, sumador de señal e inversores

https://www.youtube.com/watch?v=NL4wfVMozKA

==== OR

[width=20%]
|===
| A | B | Z
| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 1
|===

Se puede pensar OR como una compuerta que deja pasar info/comunicación de A o B en *DIFERENTE* TIEMPO

Se puede utilizar para juntar distintos canales de comunicación.

OR PUEDE *UNIR* COMUNICACIONES

*Circuito*

image::2023-10-16T21-46-07-417Z.png[]


==== AND

[width=20%]
|===
| A | B | Z
| 0 | 0 | 0
| 0 | 1 | 0
| 1 | 0 | 0
| 1 | 1 | 1
|===

Se puede pensar como un habilitador. Con B = control. Cuando B=1 deja pasar lo que tiene A. Cuando B=0, la salida es siempre 0(no deja pasar lo que esta en A)

AND PUEDE DEJAR *PASAR/NO PASAR*

*Circuito*

image::2023-10-16T21-49-34-956Z.png[] 

==== XOR

[width=20%]
|===
| A | B | Z
| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 0
|===

Se puede pensar como un inversor controlado

* Cuando B=0 Z=A (deja pasar A)
* Cuando B=1 Z=stem:[overline A]

XOR ES CNOT O NOT CONTROLADA

*Circuito*

image::2023-10-16T21-55-00-394Z.png[]

=== Componentes

¿ Para que sirven ?

Los multiplexores y demultiplexores permiten seleccionar y direccionar señales de entrada a través de una única línea de salida o entrada, respectivamente. 

Los codificadores y decodificadores se utilizan para comprimir y descomprimir la información.

=== Decodificador

Es un circuito que tiene una sola entrada y múltiples salidas

Decodifica la entrada en una forma más extensa. 

El número de bits de las salidas es mayor que el número de bits de la entrada. 

Los decodificadores se utilizan en la expansión de datos y en la recuperación de información.

image::2023-10-16T21-02-31-053Z.png[] 

VIDEO: https://www.youtube.com/watch?v=Jvxlq55QUCc

Si tiene n entradas, tiene stem:[2^n] salidas. 

* Con 2 entradas, tiene 4 salidas. 
* Con 3 entradas, tiene 8 salidas.

==== Dibujo

Ejemplo con 2 entradas y 4 salidas

image::2023-10-16T23-02-35-229Z.png[]

==== Tabla de verdad 

Ejemplo con 2 entradas y 4 salidas

[cols="10%,10%,10%,10%,10%,10%,50%"]
|===
| A | B | W | X | Y | Z |

| 0 | 0 |*1*| 0 | 0 | 0 | Si elijo 0 0, quiero que se habilite w
| 0 | 1 | 0 |*1*| 0 | 0 | Si elijo 0 1, quiero que se habilite x
| 1 | 0 | 0 | 0 |*1*| 0 | Si elijo 1 0, quiero que se habilite y
| 1 | 1 | 0 | 0 | 0 |*1*| Si elijo 1 1, quiero que se habilite z
|===

==== Diagrama de compuertas

Primero buscamos la expresión del álgebra de Boole

|===
| A | B | W | W=                            | X | X=                            | Y | Y=                            | Z | Z = 
                 
| 0 | 0 |*1*| stem:[overline A. overline B] | 0 |                               | 0 |                               | 0 | 
| 0 | 1 | 0 |                               |*1*| stem:[overline A.          B] | 0 |                               | 0 | 
| 1 | 0 | 0 |                               | 0 |                               |*1*| stem:[A. overline B]          | 0 | 
| 1 | 1 | 0 |                               | 0 |                               | 0 |                               |*1*| stem:[A.B]
|===

image::2023-10-16T23-24-29-248Z.png[] 

image::2023-10-17T00-00-11-192Z.png[] 

==== Habilitacion (AND)

Poniendo una compuerta AND de habilitación, podemos controlar que la salida se prenda o se apague con una nueva entrada H

|===
| A | B | H | W | W=                            | X | X=                            | Y | Y=                            | Z | Z = 
| 0 | 0 | 1 |*1*| stem:[overline A. overline B] | 0 |                               | 0 |                               | 0 | 
| 0 | 1 | 1 | 0 |                               |*1*| stem:[overline A.          B] | 0 |                               | 0 | 
| 1 | 0 | 1 | 0 |                               | 0 |                               |*1*| stem:[A. overline B]          | 0 | 
| 1 | 1 | 1 | 0 |                               | 0 |                               | 0 |                               |*1*| stem:[A.B]
| 0 | 0 | 0 | 0 |                               | 0 |                               | 0 |                               | 0 | 
| 0 | 1 | 0 | 0 |                               | 0 |                               | 0 |                               | 0 | 
| 1 | 0 | 0 | 0 |                               | 0 |                               | 0 |                               | 0 | 
| 1 | 1 | 0 | 0 |                               | 0 |                               | 0 |                               | 0 |

|===

image::2023-10-17T00-02-14-742Z.png[]

=== Codificador

Es un circuito que tiene múltiples entradas y una sola salida

Codifica las entradas en una forma más compacta.

El número de bits de la salida es menor que el número de bits de las entradas.

Los codificadores se utilizan en la compresión de datos y en la reducción del tamaño de los datos.

image::2023-10-16T20-29-31-974Z.png[] 

Video https://www.youtube.com/watch?v=zSi7sky2ayU

==== Dibujo

Ejemplo con 4 entradas, 2 salidas

El ejemplo muestra como con 4 entradas puedo representar el número decimal del 0 al 3

image::2023-10-17T11-02-02-053Z.png[] 

==== Dibujo

[cols="5%,5%,5%,5%,5%,5%,75%", width="70%"]
|===
| A | B | C | D | Y | Z | 
| 1 |   |   |   | 0 | 0 | Si está encendido A quiero que represente el 0
|   | 1 |   |   | 0 | 1 | Si está encendido A quiero que represente el 1
|   |   | 1 |   | 1 | 0 | Si está encendido A quiero que represente el 2
|   |   |   | 1 | 1 | 1 | Si está encendido A quiero que represente el 3
|===

Se debe tener en cuenta la prioridad. Esto es, ¿ que pasa si en las entradas hay mas de un 1 ? podría ser que para la primera entrada A=1 y B=1. Tengo que priorizar. Esto es, darle importancia al bit que yo quiera. En este caso puedo priorizar el bit de menor valor A: todos los bits de mayor valor no tendrían importancia y se tomarían como 0.

==== Diagrama de compuertas

Primero buscamos la expresión del álgebra de Boole

En esta tabla se tiene en cuenta:

. La columna inactiva, es para eliminar la doble salida de cero. Esto es cuando A=0, B=0, C=0 y D=0 la salida es 0. Pero en nosotros queremos que la salida sea 0 cuando A=1. Esto trae el problema que 2 valores de entrada pueden codificar el mismo valor de salida. Para ello, se agrega InActiva y se hace AND con esta columna, para dejar pasar o no el valor de salida
. Como hay menos ceros que unos, realizar la multplicación de sumas en vez de la suma de productos que es mas común. Se toman las columnas donde los valores dan como resultado cero,  se suman los ceros sin negar, y los 1 negados (ver tabla)

[cols="5%,5%,5%,5%,10%,20%,10%,20%,10%,10%", width="75%"]
|===
| D | C | B | A ^| Y | Y=                                ^| Z | Z=                                        | InActiva | InActiva=
| 0 | 0 | 0 | 0 ^| 0 | stem:[D+C+B+A]                    ^| 0 | stem:[D+C+B+A]                            | 0        | D+C+B+A        
| 0 | 0 | 0 | 1 ^| 0 | stem:[D+C+B+overline A]           ^| 0 | stem:[D+C+B+overline A]                   | 1        |
| 0 | 0 | 1 | 0 ^| 0 | stem:[D+C+overline B+A]           ^| 1 |                                           | 1        |
| 0 | 0 | 1 | 1 ^| 0 | stem:[D+C+overline B+overline A]  ^| 1 |                                           | 1        |
| 0 | 1 | 0 | 0 ^| 1 |                                   ^| 0 | stem:[D+overline C+B+A]                   | 1        |
| 0 | 1 | 0 | 1 ^| 1 |                                   ^| 0 | stem:[D+overline C+B+overline A]          | 1        |
| 0 | 1 | 1 | 0 ^| 1 |                                   ^| 0 | stem:[D+overline C+overline B+A]          | 1        |
| 0 | 1 | 1 | 1 ^| 1 |                                   ^| 0 | stem:[D+overline C+overline B+overline A] | 1        |
| 1 | 0 | 0 | 0 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 0 | 0 | 1 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 0 | 1 | 0 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 0 | 1 | 1 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 1 | 0 | 0 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 1 | 0 | 1 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 1 | 1 | 0 ^| 1 |                                   ^| 1 |                                           | 1        |
| 1 | 1 | 1 | 1 ^| 1 |                                   ^| 1 |                                           | 1        |
|===

stem:[Y = (D+C+B+A).(D+C+B+overline A).(D+C+overline B+A).(D+C+overline B+overline A)]

*Simplificación*:

image::2023-10-18T00-13-06-507Z.png[] 

stem:[Z = (D+C+B+A).(D+C+B+overline A).(D+overline C+B+A).(D+overline C+B+overline A).(D+overline C+overline B+A).(D+overline C+overline B+overline A)]

*Simplificación*:

image::2023-10-18T00-14-30-657Z.png[] 

*Compuertas*

image::2023-10-18T00-17-52-887Z.png[] 


=== Multiplexor (MUX)

Es un circuito que tiene múltiples entradas y una única salida.

Selecciona una de las entradas para enviarla a la salida en función de un conjunto de entradas de selección

Actúa como un selector de entrada

El número de entradas y entradas de selección determinan cuál de éstas entradas se seleccionará y se enviará a la salida.

image::2023-10-16T20-21-50-633Z.png[] 

Video1: https://www.youtube.com/watch?v=edDbm-2t1kY
Video2: https://www.youtube.com/watch?v=AMP4muh_Jqk


==== Dibujo

En este ejemplo se tienen que multiplexar 4 entradas y 1 salida. Para multiplexar 4 entradas se necesitan 2 entradas de control. 

stem:[2^"con"="in"]

* con=cantidad de entradas de control
* in=cantidad de entradas a multiplexar

image::2023-10-18T22-47-41-727Z.png[] 

Ejemplo donde pasa B

image::2023-10-18T22-52-19-656Z.png[] 

==== Tabla de verdad 


Tabla simplificada

[width="20%"]
|===
^| stem:[C_0] ^| stem:[C_1] ^| Z
^| 0          ^| 0          ^| A
^| 0          ^| 1          ^| B
^| 1          ^| 0          ^| C
^| 1          ^| 1          ^| D
|===

Tabla mas completa
(La tabla completa es de stem:[2^6=64] filas. Ver video1 para verla completa)

[cols=7, width="50%"]
|===
4+^| Entradas de información 2+^| Entradas de control ^| Salida
^| A ^| B ^| C ^| D ^| stem:[C_0] ^| stem:[C_1] ^| Z
^| 0 ^|   ^|   ^|   ^| 0          ^| 0          ^| 0
^| 1 ^|   ^|   ^|   ^| 0          ^| 0          ^| 1
^|   ^| 0 ^|   ^|   ^| 0          ^| 1          ^| 0
^|   ^| 1 ^|   ^|   ^| 0          ^| 1          ^| 1
^|   ^|   ^| 0 ^|   ^| 1          ^| 0          ^| 0
^|   ^|   ^| 1 ^|   ^| 1          ^| 0          ^| 1
^|   ^|   ^|   ^| 0 ^| 1          ^| 1          ^| 0
^|   ^|   ^|   ^| 1 ^| 1          ^| 1          ^| 1
|===

==== Diagrama de compuertas

ver como los controles son un decodificador en https://youtu.be/AMP4muh_Jqk?t=160

El resultado es este dibujo:

image::2023-10-18T23-23-23-053Z.png[] 

Este es el diagrama de compuertas

image::2023-10-18T23-25-49-872Z.png[] 




=== Demultiplexor (DEMUX)

Es un circuito que tiene una sola entrada y múltiples salidas. 

Selecciona una de las salidas para recibir la entrada en función de un conjunto de entradas de selección

Actúa como un selector de salida.

El número de salidas y las entradas de selección determinan cuál de las salidas recibirá la entrada

image::2023-10-16T20-25-32-229Z.png[] 


==== Dibujo

En este ejemplo se tienen que demultiplexar 1 entradas en 4 salidas. Para demultiplexar 1 entrada en 4 salidas se necesitan 2 entradas de control. 

stem:[2^"con"="sal"]

* con=cantidad de entradas de control
* sal=cantidad de salidas donde demultiplexar

image::2023-10-18T23-34-05-734Z.png[] 

Ejemplo donde la salida es A

image::2023-10-18T23-36-00-215Z.png[] 



==== Tabla de verdad 

[cols=7, width="50%"]
|===
^| Entrada 2+^| Entradas de control    4+^| Salidas de información 
^| Z         ^| stem:[C_0] ^| stem:[C_1] ^| A ^| B ^| C ^| D  
^| 0         ^| 0          ^| 0          ^| 0 ^|   ^|   ^|    
^| 1         ^| 0          ^| 0          ^| 1 ^|   ^|   ^|    
^| 0         ^| 0          ^| 1          ^|   ^| 0 ^|   ^|    
^| 1         ^| 0          ^| 1          ^|   ^| 1 ^|   ^|    
^| 0         ^| 1          ^| 0          ^|   ^|   ^| 0 ^|    
^| 1         ^| 1          ^| 0          ^|   ^|   ^| 1 ^|    
^| 0         ^| 1          ^| 1          ^|   ^|   ^|   ^| 0  
^| 1         ^| 1          ^| 1          ^|   ^|   ^|   ^| 1  
|===

==== Diagrama de compuertas

ver como los controles son un decodificador en https://youtu.be/_wWXKgEwiUc?t=121


image::2023-10-18T23-42-51-038Z.png[] 

== Semana 11 FLIP-FLOP

Un flip-flop es un circuito secuencial básico en electrónica digital que se utiliza como unidad básica de almacenamiento de información en sistemas digitales.

Funcionan como interruptores electrónicos que pueden cambiar su estado de salida en función de una señal de entrada, y mantienen su estado de salida anterior en ausencia de una señal de entrada.

En otras palabras, un flip-flop es un circuito secuencial que tiene como objetivo memorizar un dato binario. 

Pueden ser sincrónicas o asincrónicas

Esquema general

2 entradas

1 clock

2 salidas

image::2023-10-25T22-45-23-613Z.png[] 

=== Clock

Se usan en flip flop sincronicos. Son los que disparan el flipflop y lo hacen por flancos o por nieveles. Lo mas común es que sean disparados por flancos porque ocupan menos tiempo en generarse

=== Niveles de clock

*Alto y bajo*

Alto: cuando es 1

Bajo: cuando es cero

image::2023-10-25T22-42-08-590Z.png[] 

*Flanco descendente*

Cuando pasa de 1 a 0

image::2023-10-25T22-42-55-294Z.png[] 

Dibujo en flipflop

image::2023-10-25T22-48-26-406Z.png[] 

*Flanco ascendente*

Cuando pasa de 0 a 1

image::2023-10-25T22-43-50-086Z.png[] 

Dibujo en flipflop

image::2023-10-25T22-49-11-518Z.png[] 


=== Preset y clear

image::2023-10-25T22-50-26-539Z.png[] 

Son 2 entradas adicionales. 

Preset pone 1 a las salidas

Clear pone 0 a las salidas

=== Flip-flop SR

El flip-flop SR (set-reset) es un circuito que tiene 

* dos entradas:
** una entrada S (set) 
** una entrada R (reset) 
* dos salidas
** una salida Q 
** una salida Q complementaria.
* Tiene un clock (cuando es sincrónico)

image::2023-10-25T22-53-28-541Z.png[] 

==== Tabla de verdad

image::2023-10-25T23-49-21-371Z.png[] 

*Tabla reducida*

image::2023-10-25T23-00-47-053Z.png[] 

Q* es Q del futuro

Cuando ambas entradas son 0 se mantiene el estado anterior del ff (memoria)

Cuando s=1 y r=0, se tiene r (set)

Cuando s=0 y r=1, se tiene r (reset)

Cuando s=1 y r=1 el valor de Q  es indeterminado

==== Circuito lógico

image::2023-10-25T23-50-39-180Z.png[] 

=== Flip-flop D

Se usa para los 

* registros (guardar informacion temporalmente, memoria chiquita)
* buses (comunucacion)

Tiene:

* 1 entrada D
* 1 entrada de clock

image::2023-10-25T23-13-44-764Z.png[] 

==== Bus de datos

image::2023-10-25T23-19-07-620Z.png[] 

En el bus de datos se pone info (1 o 0) que pueden ver todos los dispositivos (D1,D2,D3,D4)

Pero cada dispositivo tiene un flip flop D  que es accionado por un pulso de clock en forma independiente.

Cuando quiero guardar en Q  del dispositivo 1, lo que hay en ese momento en el bus de datos, acciono el clock *solamente* del dispositivo 1


==== Tabla de verdad

image::2023-10-25T23-15-49-249Z.png[] 

=== T

Se usan para contadores

Tiene:

* 1 entrada T
* 1 entrada de clock
* salidas stem:[Q" y "overline Q]


image::2023-10-25T23-25-33-844Z.png[] 

==== Tabla de verdad

image::2023-10-25T23-26-38-007Z.png[] 

=== JK 

Incluyen la funcionalidad del SR, D y T

image::2023-10-25T23-33-01-212Z.png[] 


==== Tabla de verdad
image:2023-10-25T23-30-00-101Z.png[] 


=== Registros

Los registros son circuitos digitales que se utilizan para almacenar temporalmente datos en sistemas electrónicos. Los registros se utilizan en una amplia gama de aplicaciones en sistemas digitales, como la memoria temporal en procesadores, la transmisión de datos en comunicaciones digitales, la generación de señales de temporización y la implementación de lógica secuencial.

==== Clasificación

Los registros se clasifican según su estructura de entrada y salida, y se dividen en cuatro tipos: 


* SIPO (serial-in-parallel-out): este tipo de registro tiene una entrada en serie y varias salidas en paralelo. Los datos se cargan uno a uno en el registro a través de la entrada en serie y luego se pueden leer simultáneamente en las salidas en paralelo.
* SISO (serial-in-serial-out): este tipo de registro tiene una entrada en serie y una salida en serie. Los datos se cargan uno a uno en el registro a través de la entrada en serie y luego se leen uno a uno a través de la salida en serie.
* PISO PISO (parallel-in-serial-out): este tipo de registro tiene varias entradas en paralelo y una salida en serie. Los datos se cargan simultáneamente en el registro a través de las entradas en paralelo y luego se leen uno a uno a través de la salida en serie.
* PIPO (parallel-in-parallel-out): este tipo de registro tiene varias entradas en paralelo y varias salidas en paralelo. Los datos se cargan simultáneamente en el registro a través de las entradas en paralelo y luego se pueden leer simultáneamente en las salidas en paralelo.

image::2023-10-25T23-44-06-602Z.png[] 


