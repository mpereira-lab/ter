:stylesheet: daro-dark.css
:toc: left
:toclevels: 4
:toc-title: DB
:imagesdir: ./images
:stem: 

= DB

== Semana 1

=== ¿Qué es una base de datos?

*una colección de datos interrelacionados, almacenados en conjunto sin redundancias perjudiciales o innecesarias, garantizando la consistencia, la integridad y la seguridad de los mismos; cuyo fin es la de servir a una o varias aplicaciones, de la mejor manera posible. Los datos se almacenan de modo que resulten independientes de los programas que los usan*


=== ¿Qué es un dato?

Es una representación simbólica.
Por si sólo, no tiene significado. Por ejemplo 1911 ¿Es un año? ¿Es un código de una materia de facultad? ¿Es un teléfono de un radio-taxi?
Los datos son valores almacenados que representan hechos o realidades del mundo real.

=== ¿Qué es información?

Son datos procesados e interpretables. Una información dice algo.
Se refiere a los datos que han sido procesados y comunicados de tal manera que pueden ser entendidos e interpretados por el receptor. Información es el significado de los datos.

=== ¿Qué es una base de datos?
Definimos la base de datos como un conjunto de datos interrelacionados y almacenados sin redundancias innecesarias, los cuales sirven a las aplicaciones sin estar relacionados de una manera directa entre ellos.

=== Se guarda información de dos tipos.

* Los datos de usuarios (datos usados por las aplicaciones).
* Los datos de sistema (datos que la base de datos utiliza para su gestión). Ejemplo: datos de los usuarios que tienen acceso a la base de datos.

=== base de datos organizada

* Ser versátil. Dependiendo de los usuarios o las aplicaciones, se puedan hacer diferentes cosas o tratar a los datos de formas distintas. 
* Atender con la rapidez adecuada a cada aplicación o empresa.
* Tener un índice de redundancia lo más bajo posible. 
* Contar con una alta capacidad de acceso para ganar el mayor tiempo posible en la realización de consultas. 
* Tener un alto índice de integridad. Al tener muchos usuarios usando una misma base de datos, no puede haber fallos en la inserción, errores por redundancia o lenta actualización. 
* Contar con un nivel altísimo de seguridad y privacidad ya que los datos que se almacenan pueden ser altamente confidenciales o importantes. En este punto también entran los medios físicos de protección contra fuego, robo, etc. 
* Estar actualizada y evitar convertirse en una base de datos anticuada e inservible. 
* Contar con independencia física y lógica de los datos. Un cambio en la organización física de los datos no debe afectar a los programas (esta es la independencia física de los datos). Los cambios en la estructura lógica de los datos (agregar nuevos campos a una tabla) no deben afectar a las aplicaciones que utilicen esos datos (esta es la independencia lógica de los datos).

=== ¿Qué entendemos por información?

La información es el conocimiento derivado del análisis o tratamiento de los datos que se utiliza para tomar decisiones con vistas a un accionar concreto. 

=== ¿Qué es un sistema de información?

Un sistema de información es una colección de datos debidamente recopilados y estructurados que proporcionan información sobre la realidad. 

=== Los problemas de utilización de planillas

* Redundancia. Al no existir algún tipo de control sobre el ingreso más que el del usuario, es muy normal que existan registros duplicados y repeticiones. 
* Error de ingreso. Al hacer un ingreso manual de datos, son frecuentes los errores de tipo de letras y números, errores ortográficos, entre otros. 
* Estandarización. Es el tipo de error más común y se ejemplifica en el ingreso de fechas donde, a pesar de poder regir el formato de entrada, se ingresan otros formatos que, si bien pueden ser correctos, interfieren en la organización de la base de datos. Por ejemplo: 21-12-2021 o bien 21/02/2021, o 21/2/2021.
* Seguridad. No hay control de uso y acceso por parte de los usuarios de los datos, más que el control al archivo físico en la computadora local o servidor.

=== Sistemas de gestión de bases de datos

Un gestor de base de datos (DataBase Management System) es un sistema que permite la creación, gestión y administración de bases de datos, así como la elección y manejo de las estructuras necesarias para el almacenamiento y la búsqueda de la información del modo más eficiente posible.

=== características fundamentaldes de un DBMS.

* Es un componente de software. 
* Garantiza disponibilidad y accesibilidad. 
* Permite el acceso concurrente a los datos. 
* Asegura la integridad transaccional.
* Protege los datos y los accesos. 
* Optimiza la performance y el rendimiento.

=== Transacción

En las bases de datos, se denomina transacción a una única operación lógica.  

Por ejemplo, es una sola transacción la acción de transferir fondos de una cuenta bancaria a otra, aún cuando involucra varios cambios en distintas tablas.

=== ACID

Una transacción se dice ACID porque

* Atomicidad.  Esta propiedad determina que cada transacción es "todo o nada": si una parte de la transacción falla, todas las operaciones de la transacción se anulan y la base de datos no sufre cambios. Un sistema atómico tiene que garantizar la atomicidad en cualquier operación y situación, incluyendo fallas de alimentación eléctrica, errores y caídas del sistema. 
* Consistencia. La propiedad de consistencia asegura que cualquier transacción llevará a la base de datos de un estado válido a otro estado válido. Cualquier dato que se escriba en la base de datos tiene que ser válido de acuerdo a las reglas definidas
* Aislamiento ("Isolation" en inglés) . Esta propiedad asegura que la ejecución concurrente de las transacciones resulte en un estado del sistema que se obtendría si estas transacciones fueran ejecutadas una detrás de otra. Cada transacción debe ejecutarse en aislamiento total. Por ejemplo, si T1 y T2 se ejecutan concurrentemente, cada una deberá mantenerse independiente.
* Durabilidad. La propiedad de durabilidad significa que una vez que se confirmó una transacción (commit), quedará persistida incluso ante eventos como pérdida de alimentación eléctrica, errores y caídas del sistema. Por ejemplo, en las bases de datos relacionales, una vez que se ejecuta un grupo de sentencias SQL, los resultados tienen que almacenarse inmediatamente (incluso si la base de datos se cae en el instante posterior).

=== Los sistemas gestores de bases de datos

abreviado SGBD (Database Management System o DBMS) es:  son conjunto de programas que permiten a los usuarios acceder y modificar los datos. El propósito de un sistema de base de datos es proporcionar a los usuarios una visión abstracta de los datos. Es decir, el sistema esconde, ciertos detalles desde cómo se almacenan y mantiene los datos.

=== Niveles de abstracción

* Nivel interno o físico: El nivel más bajo de abstracción *describe cómo se almacenan realmente los datos* y da cuenta en detalle de las estructuras de datos complejas. Por ejemplo Un registro cliente, cuenta o empleado se puede describir como un bloque de posiciones almacenadas con consecutivamente (palabras o bytes). El compilador del lenguaje esconde este nivel de detalle a los programadores.
* Nivel conceptual o lógico: El este nivel de abstracción *describe qué datos se almacenan en la base de datos y qué relaciones existen entre esos datos*. La base de datos completa se describe así en términos de un número pequeño de estructuras relativamente simples. En el nivel lógico cada registro se describe mediante una definición de tipo y por la relación entre estos tipos de registros.  
* Nivel externo o de vistas: El nivel más alto de abstracción describe solo parte de la base de datos completa. Muchos usuarios del sistema de base de datos no necesitan toda la información, sino que necesitan acceder solo a una parte de ella. Para que su interacción con el sistema se simplifique, se define la abstracción del nivel de vistas. En el nivel de vistas, los usuarios ven un conjunto de programas de aplicación que esconden los detalles de los tipos de datos. Además de esconder detalles del nivel lógico de la base de datos, las vistas también proporcionan un mecanismo de seguridad para evitar que los usuarios accedan a ciertas partes de la base de datos.  


== Semana 2

=== Nivel abstracción lógico

En este nivel de abstracción, los/as administradores de bases de datos deciden que información guardar. Esta decisión consta de diferentes tareas.

* Definición de los datos. Se describen el tipo de datos. Longitud de campo todos los elementos direccionables en la base.
* Relaciones entre datos. Se definen las relaciones entre datos para enlazar tipos de registros relacionados para el procesamiento de archivos múltiples.

=== Uso de los modelos

Los modelos consisten en sistemas de diagramas o imágenes que permiten que más personas puedan participar en el diseño del sistema

El modelado de datos es el proceso de creación de una representación visual que define los sistemas de recopilación y administración de información de cualquier organización.

Ventajas: 

. Reduce los errores en el desarrollo de software de bases de datos. 
. Facilita la rapidez y eficacia en el diseño y creación de bases de datos.
. Facilita la comunicación entre los ingenieros de datos y los departamentos de inteligencia empresarial.


=== Modelos de datos conceptuales

Un modelo conceptual de datos identifica las relaciones de más alto nivel entre las diferentes entidades. Las características del modelo conceptual de datos incluyen:

. Incluye las entidades importantes y las relaciones entre ellas. 
. No se especifica ningún atributo. 
. No se especifica ninguna clave principal.

Modelar significa simplificar la realidad del negocio pero sin perder significancia de sus datos. 

image::2023-08-27T22-38-11-040Z.png[] 

=== Modelos de datos físicos

Un modelo de base de datos física muestra todas las estructuras de tabla, incluidos el nombre de columna, el tipo de datos de columna, las restricciones de columna, la clave principal, la clave externa y las relaciones entre las tablas. 

Los pasos básicos para el diseño del modelo de datos físicos son los siguientes:

* Convertir entidades en tablas. 
* Convertir relaciones en claves externas. 
* Convertir atributos en columnas. 
* Modificar el modelo de datos físicos en función de las restricciones/requisitos físicos.

image::2023-08-27T22-45-13-435Z.png[] 

=== Modelos de datos lógicos

Un modelo de datos lógicos describe los datos con el mayor detalle posible, independientemente de cómo se implementarán físicamente en la base de datos.

Las características de un modelo de datos lógicos incluyen:

. Se representan las entidades y sus relaciones.
. Se especifican los atributos para cada entidad.
. Se sitpua la clave principal para cada entidad y las claves externas (claves que identifican la relación entre diferentes entidades)
. La normalización ocurre en este nivel.

 A partir de estas caracteristicas, podemos definir y ordenar los pasos para diseñar un modelo de datos lógicos.

. Especificar claves primarias para todas las entidades. 
. Encontrar las relaciones entre diferentes entidades. 
. Describir todos los atributos para cada entidad. 
. Resolver las relaciones de muchos a muchos. 
. Normalización.

image::2023-08-27T22-47-58-250Z.png[] 

== Semana 3

=== Modelo Entidad-Relación (MER)

Representa al mundo real en un conjuntos de objetos llamadas entidades y y la relacion entre las entidades.

Se utiliza para el diseño de la base de datos el cual representa la especificación de un esquema de empresa

Representa la estructura lógica general de la base de datos. 


=== Integridad

* Integridad de entidad: ningún atributo que participe de la clave principal puede tener valores nulos
* Integridad referencial: si una entidad tiene propiedad que es clave extranjera, es decir es clave principal en otra entidad, cada valor de esa propiedad debe ser igual a algún valor de la clave principal de la segunda entidad.

=== Propiedades de tablas

. Para cada columna existe un conjunto de valores permitidos
. Cada tabla puede tener registros del mismo tipo
. Para registros distintos se usan tablas distintas
. En cada tabla debe existir una clave formada por uno o varios campos
. No puede haber campos iguales en los registros
. Cada columna de una tabla representa una relación entre un conjunto de valores
. La tabla es considerada una relación en sentido matemático

=== Entidad

Una entidad es un objeto que existe y es distinguible de otros objetos. Se expresa la distinción asociando con cada entidad al conjunto de atributos que describen el objeto.
Es un objeto del que se recoge información de interés de cara a la base de datos.

* Entidades fuertes son las que no dependen de otras entidades para existir. 
* Entidades débiles siempre dependen de otra entidad, no tienen sentido por ellas mismas.

Se los representa con un rectangulo

image::2023-09-02T19-57-24-638Z.png[] 

=== Relación

Es un vínculo entre 2 entidades. 2 Entidades participantes de una relación, son entidades participantes. A cada entidad se le asigna un nombre para poder distinguirla de las demás y saber su función dentro de un modelo.

Muestra la asociación entre entidades. Una entidad puede estar conectada a una o más relaciones pero nunca conectada  directamente a otra entidad. 


==== Grados de relación

Las propiedades de la relación son:

* Grados: 
** Grado 1: relaciona una entidad consigo misma. (Unario)
** Grado 2: relaciona 2 entidades (Binario)
** Grado n: relacionan mas de 2 entidades (Ternario cuando son 3)

image::2023-09-02T19-59-35-546Z.png[] 


=== Atributos 

Son propiedades de entidades y relaciones que toman un valor en una instancia particular. El dominio es el conjunto de valores validos que puede tomar una propiedad.

 Ejemplo: Si la entidad es “Examen”, y una propiedad es “Nota” su dominio puede ser un número del 1 al 10

==== Tipos de atributos

* Identificador único - clave primaria: conjunto de atributos (1 o más) que sirven para identificar unívocamente a cada entidad del mismo tipo
* Atributos derivables: a veces, resulta útil poder representar a determinados atributos, cuyas instancias están en función de otros atributos de la misma entidad
 
 Ejemplo: atributo edad de una persona, puede ser calculable a partir de la fecha de nacimiento

* Atributos compuestos: son aquellos atributos que tienen subatributos que con los cuales forman una jerarquía
 
 Ejemplo: Domicilio posee: Calle, Altura, CP, Localidad y Provincia

image::2023-09-02T20-31-58-762Z.png[] 

=== MER: Cardinalidad/Conectividad de una relación

Tambien se lo conoce como "Conectividad de una relación"

*Por conectividad entendemos a la cantidad de instancias de un objeto que participan en la relación con otro objeto*

* Uno a muchos (1 a N). 

image:2023-09-02T20-36-23-744Z.png[] 

* Uno a uno (1 a 1)

image::2023-09-02T20-36-46-735Z.png[] 

* Muchos a muchos (N a M)

image::2023-09-02T20-37-02-990Z.png[] 

video: https://www.youtube.com/watch?v=KrEFCpPZ8dE

=== Modalidad / condicionalidad

* Obligatoria: Si para todo registro de A debe existir siempre al menos un registro de B
* Optativa: Si para todo registro de A, pueden existir o no, uno o varios registros de B
* La modalidad de las relaciones se debe analizar en ambos sentidos

=== Diagrama entidad - relación

image::2023-09-02T20-46-07-567Z.png[] 

=== Relaciones


=== Tuplas

Se trata de cada una de las filas de la tabla. Es importante señalar que no se pueden tener tuplas duplicadas en una tabla. Las relaciones se representan gráficamente con rombos, dentro de ellas se coloca el nombre de la relación.

Propiedades de la relación

=== Normalización

La normalización es un mecanismo que permite que un conjunto de tablas cumpla una serie de propiedades que eviten:

* Redundancia de datos
* Anomalías de actualización
* Pérdidas de Integridad de datos

El objetivo de la normalización es construir una BD que minimice la redundancia de información; para ello es necesario reagrupar los atributos de cada tabla del modelo.

La redundancia puede generar anomalías de *inserción, borrado y modificación"

Ejemplo: 

image::2023-09-02T21-34-10-219Z.png[] 

* Anomalías de Inserción: Si se agrega un nuevo empleado, se debe indicar toda la información, incluyendo repetir el nombre del departamento donde trabaja, aunque sea un departamento ya existente en la tabla. Se debe tener especial cuidado en describir al departamento de forma similar a lo que se hubiese hecho anteriormente. Se observa que la información almacenada es incorrecta, ya que el departamento con idDepto 2 no puede tener dos nombres diferentes.  Esta situación se produce al generar redundancia de información. Cada vez que se agrega un empleado a un departamento existente, debe ingresarse el nombre del departamento, lo cual es innecesario.

* Anomalías de Borrado: si se elimina al empleado María, que trabaja en el departamento de Ventas. Al borrar esa tupla, en la misma operación se borra información del departamento donde trabaja, y como era la única empleada registrada para ese departamento, se pierde “Ventas” como departamento de la organización. 

* Anomalías de Modificación: al suponer que debemos cambiar el nombre de departamento de "Electronica y computacion" por el nombre "Tecnología", la redundancia nos obliga a cambiar varias tuplas para cambiar todos los nombres donde el 
departamento sea idDepto = 2. En el caso de algun inconveniente, la informacion del departamento puede quedar inconsistente o con falta de integridad, ya que en algunos registros puede quedar como "Electronica y computacion" y en otros como "Tecnología"

==== Dependencia funcional

La dependencia funcional se establece entre "atributos" de una "relación". Por lo tanto, dados 2 atributos a y b pertenecientes a una relación Q, se define dependencia funcional en Q si al valor de b esta relacionado a cada valor de a.

==== Valor atómico

Los valores de los atributos no son multi-valorados

==== Dependencia de los atributos no clave con la Clave Primaria

Cuando la clave primaria es compuesta, puede suceder que algunos de los atributos no clave, dependan de uno de los atributos de la clave primaria. En el que la clave primaria esta compuesta por un solo atributo, la dependencia es verdadera.


=== Primera forma normal

* Debe existir una clave principal (primaria).
* Todos los valores de atributos deben ser atómicos. Es decir, no deben haber listas, conjuntos, matrices u otros tipos de datos complejos

image::2023-09-02T22-52-10-073Z.png[] 

* No deben existir grupos de valores repetidos.

image::2023-09-02T22-52-51-991Z.png[] 

=== Segunda forma normal

* Debe estar en primera forma normal
* No deben existir dependencias funcionales parciales. Esto significa que todos los valores de las columnas de una fila deben depender de la clave primaria de dicha fila, entendiendo por clave primaria los valores de todas las columnas que la formen, en caso de ser más de una.

* Las tablas que están ajustadas a la primera forma normal, y además disponen de una clave primaria formada por una única columna con un valor indivisible, cumplen ya con la segunda forma normal. Ésta afecta exclusivamente a las tablas en las que la clave primaria está formada por los valores de dos o más columnas, debiendo asegurarse, en este caso, que todas las demás columnas son accesibles a través de la clave completa y nunca mediante una parte de esa clave. 

Ejemplo:

image::2023-09-02T23-05-24-786Z.png[] 

La clave de esta tabla es id_orden+num_art

Para acceder al artículo RAQUETA se accede a través de una parte de la clave primaria (campo num_art = 4011). Esto no está en segunda forma normal. Para llavarlo a segunda forma normal, se puede hacer 

image::2023-09-02T23-07-46-275Z.png[] 

=== Tercera forma normal

* Está en 2FN
* No deben existir dependencias transitivas entre las columnas de una tabla, lo cual significa que las columnas que no forman parte de la clave primaria deben depender sólo de la clave, nunca de otra columna no clave.

Una dependencia transitiva ocurre cuando una columna no clave depende de otra columna no clave en lugar de depender directamente de la clave primaria

Ejemplo:

image::2023-09-02T23-11-31-101Z.png[] 

El nombre del cliente y el estado no dependen de la clave primaria Id_orden, sino que dependen del atributo id_cliente

Normalización:

image::2023-09-02T23-15-09-531Z.png[] 

== Semana 4

=== Álgebra relacional

==== Tipos de operaciones

. Operaciones binarias: son las que tienen dos relaciones como operandos. Son binarias todas las operaciones, excepto la selección y la proyección.
. Operaciones unarias: son las que tienen una sola relación como operando. La selección y la proyección son unarias.
. Operaciones conjuntistas: son las que se parecen a las de teoría de conjuntos. Se trata de la unión, la intersección, la diferencia y el producto cartesiano.


==== Operaciones

* Selección: sirve para elegir algunas tuplas de una relación y eliminar el resto

image::2023-09-09T21-23-34-468Z.png[] 

* Proyección: sirve para elegir algunos atributos de una relación y eliminar el resto

image::2023-09-09T21-25-54-869Z.png[] 

* Unión: partir de dos relaciones, obtiene una nueva relación formada por todas las tuplas que están en alguna de las relaciones de partida. La unión de dos relaciones T y S se indica T ∪ S. Elimina las tuplas repetidas|.

* Intersección:  a partir de dos relaciones, obtiene una nueva relación formada por las tuplas que pertenecen a las dos relaciones de partida. La intersección de dos relaciones T y S se indica T ∩ S.

* Diferencia: obtiene una nueva relación formada por todas las tuplas que están en la primera relación y, en cambio, no están en la segunda. La diferencia entre las relaciones T y S se indica como T - S.

* Producto cartesiano: obtiene una nueva relación formada por todas las tuplas que resultan de concatenar tuplas de la primera relación con tuplas de la segunda. 

image::2023-09-09T21-40-01-701Z.png[] 

* Producto cartesiano natural: es una operación que, a partir de dos relaciones, obtiene una nueva relación formada por todas las tuplas que resultan de concatenar tuplas de la primera relación con tuplas de la segunda siempre y cuando tengan el mismo valor del atributo en común.

image::2023-09-09T21-42-29-945Z.png[] 


=== SQL

==== Tipos de comandos

|===


|DDL (Data Definition Language)     |   Definir, modificar y eliminar esquemas de relaciones.
            
                                        Crear índices, definir vistas y especificar restricciones de integridad.

                                        Ejemplos: CREATE, ALTE, DROP.
|DML (Data Manipulation Language)   |  Consulta, actualizar y eliminar los elemento creados con el DDL como tablas, índices.
            
                                        Basado en el algebra relacional
            
                                        Ejemplos: SELECT, INSERT,UPDATE, DELETE.
|DCL (Data Control Language)        |   Definir permisos de acceso a la base de datos
            
                                        Ejemplo: GRANT, REVOKE.
|===


==== InnoDB (MySql)

Es un mecanismo de almacenamiento de datos de código abierto para la base de datos MySQL, incluido como formato de tabla estándar en todas las distribuciones de MySQL a partir de las versiones 4.0. Su característica principal es que soporta transacciones de tipo ACID y bloqueo de registros e integridad referencial. InnoDB ofrece una fiabilidad y consistencia muy superior a MyISAM, la anterior tecnología de tablas de MySQL, si bien el mejor rendimiento de uno u otro formato dependerán de la aplicación específica.

==== Comandos MySql

* Create database nombre_db;
* Drop database nombre_db;
* create table Socio( 
    CodSocio int, 
    DNI varchar (10), 
    Nombre varchar (60), 
    Apellido varchar (60), 
    Direccion varchar (30), 
    Tel varchar (15), 
    constraint pkpersona primary key (CodSocio) 
    )engine=innodb; 
* alter table nombre_tabla ...
** ALTER TABLE nombre_tabla ADD FOREIGN(atributo) REFERENCES Table(Atributo); 
** ALTER TABLE nombre_tabla ADD COLUMN [atributo] [tipo de datos];
* Select [lista_atributos] from [tabla] where [predicado];

==== Algebra relacional a SQL

image::2023-09-09T22-56-13-403Z.png[] 

==== Integridad de datos

Son restricciones, controles y validaciones que diseñamos para proteger la información almacenada en la base de datos y que la misma quede libre de incoherencias según nuestro criterio y la lógica de negocio de los datos que se modelan.

*Propiedades para asegurar la integridad de los datos* 

* Tipos de dato, definiciones NULL y NOT NULL.
* Valores por omisión para campos con definiciones DEFAULT
* Propiedades IDENTITY 
* Reglas de validación con la propiedad CHECK 
* Desencadenadores (triggers)
* Índices
* Claves primarias/foráneas    

==== integridad de atributo

* Validación de las entradas en una determinada columna

Se puede asegurar la integridad de dominio restringiendo el tipo (a través de tipos de dato), el formato (a través de las restricciones CHECK y de las reglas de validación) o el rango de valores posibles (restricciones CHECK, definiciones DEFAULT, definiciones NULL y NOT NULL).

==== Clave primaria

Un atributo o a una combinación de atributos que identifica de forma única a cada fila de una tabla

Cada columna que forme parte de la clave primaria queda implícitamente definida como NOT NULL.

==== Clave foránea

Es aquella columna que existiendo como dependiente en una tabla, es a su vez clave primaria en otra tabla

Una restricción foreign key no puede modificarse, debe eliminarse y volverse a crear.

== Semana 5

=== Instalación mySql

* Bajarse mySql de www.mysql.com

* Ingresar a MySQL Community Server y luego cliquear en:

image::2023-09-14T10-48-24-407Z.png[] 

* Seleccionamos el archivo que queremos descargar:

image::2023-09-14T10-48-47-870Z.png[] 

* Descargamos el archivo:

image::2023-09-14T10-49-07-858Z.png[] 

* Version 

image::2023-09-14T10-49-34-163Z.png[] 

=== Instalar XAMPP

* Buscar y descargar XAMPP

* Uso

image::2023-09-14T10-50-38-164Z.png[] 

Ojo que si se instala el server mySql, este queda funcionando y cuando se quiere activar por este panel de control da error porque ya esta levantado

* De las dos opciones indicadas en la imagen vamos a elegir acceder al “Shell”

image::2023-09-14T11-39-57-929Z.png[] 

* Después del clic en el Shell, el entorno es el siguiente:

image::2023-09-14T11-40-53-409Z.png[] 

* Para trabajar con MySQL debemos posicionarnos en ese directorio, para ello, debemos escribir la siguiente sintaxis:
 
 mysql -u root -p

====
* Mysql => indica el directorio
* u => quiere decir usuario
* Root =>  es el usuario administrador, el que tiene todos los permisos 
* -p => quiere decir password, luego del enter se debe ingresar la contraseña que se colocó cuando se instaló la herramienta. En caso de no tener contraseña se vuelve a dar enter para posicionarnos en el directorio de mysql
====

* La consola debería quedar como se muestra en la imagen.

image::2023-09-14T11-43-09-761Z.png[] 
=== Como ejecutar un .sql

mysql -u root -p < archivo_sentencias.sql

=== Sentencias DDL

*Crear base de dadtos"

* create database Biblioteca;
* use biblioteca;

*Crear tabla*

 create table Socio(CodSocio int, 
    DNI varchar (10), 
    Nombre varchar (60), 
    Apellido varchar (60), 
    Direccion varchar (50), 
    Tel varchar (15), 
    constraint pk_socio primary key (CodSocio)
 );

*Tabla con clave foránea (foreign key)*

 create table ejemplar (
    idEjem int auto_increment,
    codLibro int,
    NEjemplar int,
    Deteriorado boolean,
    Prestado boolean,
    constraint pk_ejemplar primary key (idEjem),
    constraint fk_ejemplar foreign key (CodLibro) references Libro (CodLibro)
 );

*pk compuesta*

 create table LibroAutor (
    CodLibro int,
    CodAutor int,
    constraint pk_LibroAutor primary key (CodLibro, CodAutor)
 );

=== Sentencias DML

==== consultas

====
*select* lista_atributos *from* tabla *where* predicado
====

* Cuadro se muestran las cláusulas básicas para manipular los datos almacenados:

[cols="15%,30%,55%"]
|===
|Operador       | Definición                                                        | Sentencia
| DISTINCT      | Elimina tuplas repetidas en el resultado.	                        | SELECT DISTINCT oficio FROM empleado;

                                                                                      Muestra una sola vez cada uno de los oficios de los empleados.
|BETWEEN         |Cuando el dominio del predicado pertenece a un rango de valores.  | SELECT codigo_c, nombre +
                                                                                        FROM empleadO + 
                                                                                        WHERE salario BETWEEN 10000 AND 1600;

                                                                                        Muestra el código y el nombre de los empleados con salario entre 10000 y 16000 pesos inclusive.

|Cambio de nombre
| Cuando se desea cambiar el nombre de las tablas en los productos
 cartesianos se empleas AS o se deja un espacio entre el nombre de
                  la tabla y su alias.
| SELECT * +
   FROM alumno A, materia M +
   WHERE A.legajo = M.legajo;

 Renombra a la tabla alumno con A y a la tabla materia con M.
|ORDER BY       | Permite ordenar el resultado de la consulta.                      | SELECT * +
                                                                                         FROM empleado +
                                                                                          WHERE salario = 15000 + 
                                                                                           ORDER BY nombre;

                                                                                      Muestra los datos de los empleados que cumplen la condición ordenadas de manera ascendente por su nombre. Para ordenarlos de manera descendente se debe agregar DESC. Se puede indicar más de una criterio de ordenación, estos van separados por coma.

|LIKE           
| Cuando necesitamos buscar tuplas que "contengan" determinada información, 
 sin necesidad de coincidir exactamente. Utiliza un comodín => %
| SELECT * +
  FROM empleado +
   WHERE nombre +
    LIKE "M%";

Muestra los datos de los empleados cuyo nombre comienza con M.

Formatos:

"Ma%" => comienza con Ma +
"%Ma%" => contiene Ma +
"%Ma" => termina con Ma +


|===


==== Funciones de agregación

image::2023-09-14T21-33-39-382Z.png[] 

==== Funciones de agrupación 

image::2023-09-14T21-34-05-902Z.png[] 

==== Valores nulos

image::2023-09-14T21-38-15-039Z.png[] 

==== CRUD

Create, Read, Update, Delete

image::2023-09-14T21-38-40-775Z.png[] 


== Semana 6

=== Consultas sobre varias tablas

==== Consultas con varias tablas: Junta natural explicada con ejemplos

===== Paso 1 -  Comencemos con el análisis

1) Ejecutamos las siguientes instrucciones:

Select * From socio;

Select * From prestamo;

El resultado es el siguiente: 

|===
| CodSocio | DNI      | Nombre         | Apellido | Direccion           | Tel      

|    20145 | 11452452 | Maria Josefuna | Luro     | Av Nazca 21478 CABA | 47857855 
|    20154 | 19785452 | Marcos         | Nevarez  | Trelles 1234 CABA   | 47852154 
|    21474 | 22145986 | Karina         | Quirno   | Bolivia 52345 CABA  | 47851414 
|    21489 | 20145874 | Juliana        | Laprida  | Bacacay 10789 Haedo | 49061236 
|===

|===
| NPrestamo | CodSocio | FPrestamo  | FDevolucion | FTope      

|         1 |    20154 | 2023-03-29 | 2023-04-08  | 2023-04-08 
|         2 |    20154 | 2023-04-01 | 2023-04-08  | 2023-04-10 
|         3 |    21489 | 2023-04-01 | 2023-04-08  | 2023-04-10 
|         4 |    20154 | 2023-04-02 | 2023-04-11  | 2023-04-11 
|===

Como podemos ver la tabla socio tiene 5 filas y la tabla préstamo 3 filas, si hacemos el producto cartesiano el resultado tendrá 5*3 = 15 filas.


2) Ahora ejecutamos la siguiente instrucción:

Select * From socio, prestamo;

En pantalla veremos:

image::2023-09-24T21-41-46-361Z.png[] 

La gráfica muestra las 6 columnas de socio y a continuación las 5 columnas de préstamo.

Vemos que la primera fila de socio se relacionó con todas las filas de préstamo, y así sucesivamente hasta la fila cinco de socio.

Con un círculo está marcado la columna de relación, el primer círculo es la PK de socio y el segundo círculo la FK de préstamo.


===== Paso 2 - ¿Son válidas las filas?

Observar detenidamente la siguiente imagen:

image::2023-09-24T21-43-37-106Z.png[] 

====

Observar con atención la primera fila de socio.

María Josefina Luro tiene el código de socio 20145 y cuando analizamos con el código de socio que figura en la tabla préstamo vemos que ninguno coincide, ya que son 20154, 21474 y 20154, esto significa que María Josefina no llevó libros prestados.

====

Otro ejemplo

Ahora analicemos la segunda fila de socio que es Marcos Nevarez.

image::2023-09-24T21-44-56-272Z.png[] 

Marcos Nevarez tiene el código de socio 20154 y cuando analizamos con el código de socio que figura en la tabla préstamo  hay dos coincidencias, esto quiere decir que Marcos realizo dos prestamos

Podemos seguir con el resto de los socios, y resulta que Karina Quirno que tiene el código de socio 21474 solicitó un préstamo, que Juliana Laprida con código de socio 21489 no llevó libros y que Viviana Martinez con código de socio 21523 tampoco llevó libros.

Vemos entonces que hay filas que presentan errores ya que no coinciden los dominios de las columnas en común.

===== Paso 3 - ¿Cómo salvamos los errores?

Para tener resultados correctos los dominios de las columnas que están involucradas en la relación deben ser iguales, entonces la sintaxis correcta es la siguiente:

image:2023-09-24T21-46-36-441Z.png[] 

====
Vemos que la coma entre socio y préstamo indica el producto cartesiano y la condición de igualdad de atributos está en el where, esta notación simula el algebra relacional.
====


Contamos con otro formato, el que usaremos durante el curso, donde la coma se reemplaza por la sentencia “inner join” y la igualdad de los atributos se coloca a continuación.

image:2023-09-24T21-47-17-723Z.png[] 

La palabra clave inner join selecciona todas las filas de ambas tablas siempre que haya una coincidencia entre las columnas, la columna se indica después de la palabra reservada on, en este caso es el codsocio.

===== Paso 4 - ¿Cómo evitar el error de “ambiguo”?

Volvamos a la imagen del capítulo anterior:

image::2023-09-24T21-48-51-635Z.png[] 

----
¿Observaste que en la sintaxis de la consulta hay una notación diferente? ¿Notaste que el nombre del atributo lleva delante el nombre de la tabla?
----

Como el nombre de la columna es el mismo en la tabla socio y en la tabla  préstamo, se debe indicar la procedencia y es por eso que se antepone separado por un punto el nombre de la tabla; si no se coloca el nombre, no se ejecuta y produce un error indicando que el nombre es ambiguo (no sabe a qué tabla ir).

Veamos qué resultado arrojó esa sentencia:

image::2023-09-24T22-15-24-210Z.png[] 

Ahora vemos que el codsocio de la tabla socio coincide con el codsocio de la tabla préstamo para cada fila del resultado de la consulta.

----
Ya aprendimos como utilizar dos tablas en una consulta ¿pero es el resultado que pide la consigna inicial? La respuesta es  no.
----

===== Paso 5 - Resultado final

Observemos la siguiente imagen:

image:2023-09-24T22-16-22-868Z.png[] 

----
La consigna pide nombre y apellido del socio que tiene el préstamo N° 6.
----

Debemos considerar el filtro de búsqueda. Para ello usamos el where y debemos proyectar solo las columnas que nos piden.

Ahora sí el resultado que muestra  la consulta es el correcto. Y así lo podemos ver en la pantalla.

image::2023-09-24T22-16-58-912Z.png[] 

==== Ejemplo de consulta

Mostrar los códigos de los libros de cada préstamo .

Tablas involucradas ---->>  detallePre y Ejemplar

Atributo en común ----->> idejem

Condiciones ---->> ninguna

image::2023-09-24T22-17-45-314Z.png[] 

----
Importante. Si utilizamos más de una tabla, estas deben tener un atributo en común y para que los datos sean consistentes las columnas en común se deben igualar.
----

==== Uso de más de dos tablas

Veamos ahora qué sucede si la consulta tiene más de dos tablas, para ello consideremos la última consulta con alguna modificación.

La consulta propuesta en el anterior capítulo decía Mostrar los códigos de los libros de cada préstamo; la modificamos de la siguiente manera: Mostrar los títulos de los libros de cada préstamo ordenados por préstamo.

Tablas involucradas --->>  detallePre, Ejemplar y Libro ¿Por qué estas y no otras? Porque detallePre  además del número de préstamo muestra cual es el ejemplar del libro que se presta, en ejemplar está el código del libro que le corresponde al ejemplar prestado  y en  libro esta el título que es el dato que debemos mostrar.
Atributo en común --->> entre detallePre y Ejemplar es idEjem y entre Ejemplar y Libro  es codLibro. ¿Cómo sabemos esto? Por el MER.

Condiciones -->> ninguna

*Sintaxis de la consulta*

image::2023-09-24T22-19-26-546Z.png[] 

Cuando en la consulta se tienen más de dos tablas en juego, el procedimiento de resolución es el siguiente: el gestor toma las dos primeras realiza el producto cartesiano y el resultado lo considera como un único elemento, luego lo vincula con la tabla siguiente procediendo nuevamente con el producto cartesiano y así sucesivamente hasta agotar las tablas.

----
Nota. Si querés observar cómo trabaja el gestor, ejecutá la instrucción anterior y en lugar de proyectar los atributos solicitados colocá el * (asterisco) y verás que están todos los atributos de las tablas intervinientes.
----

=== Subconsultas

Una subconsulta es una instrucción select - from - where que está anidada dentro de otra consulta

La subconsulta se ejecuta una vez antes de ejecutarse la consulta principal.

Los resultados de la subconsulta son utilizados en la consulta principal.

Si estamos seguros de que la subconsulta devuelve un único valor, es posible utilizar los operadores de comparación habituales =, < >, <=, <, >=, >

Para subconsultas que devuelven múltiples valores se pueden utilizar los operadores: In / not in

Los operadores de comparación habituales junto a los cuantificadores *any, some y all*. El predicado de comparación cuantificado con any o some se evalúa a cierto si lo es para alguna fila de la expresión de tabla. El predicado de comparación cuantificado con all se evalúa a cierto si lo es para todas  las filas de la expresión de tabla.
La ubicación de la subconsulta en la consulta principal puede ser en el select, en el from  o en el where.

==== Caso 1: subconsultas en el "select"

Cuando la subconsulta está en el select debe arrojar un único valor, es decir, el resultado tiene una fila y una columna.

Supongamos que queremos saber el nombre / apellido y cuántos préstamos solicitó el socio con código 21489. Las tablas que intervienen son socio, para mostrar el nombre, y préstamo, para contar la cantidad de veces que aparece en esa entidad.

Seguramente la consulta que pensamos es:

image::2023-09-24T22-26-29-915Z.png[] 

Con subconsulta:

Transformemos la consulta agregando una subconsulta en el select, esto es posible ya que el nombre y apellido es único para el código de socio 21489, pero para mostrarlo deben estar ambos en una sola columna, ya que como dijimos antes debe tener una sola fila y una sola columna.

Veamos cómo queda:

image::2023-09-24T22-27-01-328Z.png[] 

====  Caso 2: Subconsulta en el "from"

Cuando la subconsulta está en el from se utiliza como si fuese una tabla, es decir las columnas que proyecta la consulta se consideran como los atributos de una tabla ficticia a la que le asignamos un nombre, por lo tanto, puede tener múltiples columnas y filas.

Supongamos que queremos conocer los autores de los libros de la editorial McGraw-Hill y de la editorial MP Ediciones. Las tablas que intervienen son libro, porque tiene la editorial, libroautor para conocer el código de autor y a través de la tabla autor saber quiénes son.

Seguramente la consulta que pensamos es:

image::2023-09-24T22-28-57-028Z.png[] 


Con subconsulta:

Transformemos la consulta colocando una subconsulta en el from.

La propuesta es armar una consulta que proyecte los códigos de libro de las editoriales en cuestión y utilizarla como tabla en el from.

Veamos cómo es:

image::2023-09-24T22-29-20-271Z.png[] 

==== Caso 3: Subconsulta en el where

Cuando la subconsulta está en el  where  puede devolver uno o varios valores, es decir, tiene una o varias filas, pero solamente una columna. Dependiendo de los valores se utilizarán unos operandos u otro.


Veamos un ejemplo

Tomemos la consulta del caso 2  (subconsulta en el from) “conocer los autores de los libros de la editorial McGraw-Hill y de la editorial MP Ediciones”.

image::2023-09-24T22-30-46-049Z.png[] 

===== Errores frecuentes a nivel del where

La subconsulta en el “where” indica que estamos buscando para un atributo determinado un valor o varios valores, los cuales son el resultado de una subconsulta.

Si buscamos un valor quiere decir que o es igual, o es mayor, o es menor o las posibles combinaciones.

Si buscamos varios valores quiere decir que puede tomar más de un valor del conjunto de dominios arrojados por la subconsulta; los operadores a utilizar son in, not in,  any, some, y all.

Pero si es tan simple, ¿dónde está el error?


El error se presenta en los siguientes casos:

La subconsulta tiene más de una columna.
La subconsulta devuelve varias filas y el operador utilizado es un igual, mayor,  menor  o las combinaciones.
Estos errores ocurren porque las consultas y subconsultas se razonan en función de los dominios almacenados en lugar de razonarlas en función del requerimiento y la regla de negocios. Se piensa que los datos posibles son solamente los existentes y se olvida que las tablas son flexibles.

== Semana 9 Joins

=== Inner Join

Inner consiste en combinar cada fila de una tabla con cada fila de la otra tabla, seleccionado aquellas filas que cumplan una determinada condición.

image::2023-10-20T11-23-05-607Z.png[] 

image::2023-10-20T11-24-57-135Z.png[] 

=== Left outer Join

Esta combinación externa nos permite armar el resultado con las tuplas coincidentes entre ambas tablas (la intersección) y las tuplas de la tabla colocada a la izquierda de join que no tienen relación con la tabla de la derecha.

image::2023-10-20T11-25-31-359Z.png[] 

image::2023-10-20T11-25-17-143Z.png[] 

====
Tabla A   left outer join   Tabla B   on    A.atributo_Comun = B.Atributo_Comun
====


=== Left outer join with exclusion

Las filas de A que no se relacionen con B.

En teoría de conjunto esto es A - B (A menos B)

image::2023-10-20T11-28-34-591Z.png[] 

Para obtener este resultado, le agregamos a la sentencia del left outer join una condición, esa condición es que proyecte las filas en las cuales el código del mecánico de la tabla  mecdiag  sea null. Con esta condición quitamos del resultado las filas de la intersección.

image::2023-10-20T11-30-16-127Z.png[] 

====
Tabla A  left outer join Tabla B on A.atributo_Comun = B.Atributo_Comun Where B.atributo_Comun  is null
====

=== Right outer join
 
 Nos permite armar el resultado con las tuplas coincidentes entre ambas tablas (la intersección) y las tuplas de la tabla colocada a la  derecha de join, que no tienen relación con la tabla de la izquierda. 

image::2023-10-20T11-35-39-495Z.png[] 

image::2023-10-20T11-36-28-303Z.png[] 

====
Tabla A   right outer join   Tabla B    on   A.atributo_Comun = B.Atributo_Comun
====

=== Right outer join with exclusion

es similar que la left outer join with exclusion, con la diferencia que la condición hace referencia a la columna en común de la tabla de la izquierda. Esa columna debe ser null


image::2023-10-20T11-38-24-862Z.png[] 

image::2023-10-20T11-39-12-381Z.png[] 

====
Tabla A   right outer join   Tabla B   on    A.atributo_Comun = B.Atributo_Comun Where  A.atributo_Comun   is null
====

==== Ejemplo 1

La consulta proyecta los datos de los mecánicos que diagnostican que no participaron en el diagnostico de las fichas ingresadas al taller mecánico.

image::2023-10-20T11-45-39-855Z.png[] 

El mismo resultado lo podemos obtener con subconsulta en la condición.

image::2023-10-20T11-46-00-366Z.png[] 

==== Ejemplo 2

image::2023-10-20T11-48-57-640Z.png[] 

Clientes que tienen más de un vehículo

Solución 1

image::2023-10-20T11-50-16-135Z.png[] 

Solución 2

image::2023-10-20T11-50-34-518Z.png[] 
   
Solución 3

image::2023-10-20T11-50-47-422Z.png[] 



=== Unión

se usa para combinar más de un resultado de consulta select en una sola consulta que contiene filas de todas las consultas de selección; o puede tratarse de dos tablas con la misma estructura.

La cantidad de columnas y tipos de datos en las sentencias select debe ser la misma es decir tener la misma estructura, las columnas del mismo tipo de datos y en el mismo orden.

El resultado de la unión elimina las filas que son iguales.

image::2023-10-20T11-42-42-656Z.png[] 

image::2023-10-20T11-43-24-334Z.png[] 


== Semana 10 Consulta complejas

=== Funciones fecha

* Mostrar la fecha actual 

====
 select curdate();
====

* Mostrar fecha y hora actual 

====
 select now();
====

* Mostrar hora actual

====
 select curTime();
====

* Mostrar año, mes, dia, hora, ultimo dia del mes de una fecha 

====
 select YEAR(now());  /* ==   Selecciona el año == */
 select MONTH (now()) as mes; /* == Selecciona el mes == */
 select DAY(now()) as dia;   /* == Selecciona el día == */
 select TIME(now()) as hora;  /* == Selecciona la hora == */
 select LAST_DAY(now());  /* == Selecciona el ultimo dia del mes == */
====

* Dar formato a la fecha

====
 select Date_format("2023/08/01",'%Y/%M/%d');    /* ==  '2023/August/01 == */
 select Date_format("2023/3/12",'%Y-%M-%d %h:%i:%s %p');  /* == '2023-March-12 ..:..:.. AM' == */
 select Date_format("2023/03/12",'%W %d %M %Y'); /* ==  'Sunday 12 March 2023' == */
 select Date_format(now(),'El año actual es %Y'); /* ==  'El año actual es ....' == */
====

* Sumar y Restar tiempo 

====
 select DATE_ADD(Curdate(),INTERVAL 20 DAY); /* == Agrega 20 días a la fecha actual  == */
 select DATE_ADD(now(),INTERVAL 30 MINUTE); /* == Agrega 30 minutos a la fecha actual == */
 select DATE_ADD(Curdate(),INTERVAL 50 YEAR); /* == Agrega 50 años a la fecha actual == */
 select DATE_ADD(Curdate(),INTERVAL '10-5' YEAR_MONTH); /* == Agrega 10 años 5 meses a la fecha actual == */
 
 select DATE_SUB(Curdate(),INTERVAL 8 YEAR); /* == Resta 8 años a la fecha actual == */ 
 select DATE_SUB(now(),INTERVAL 24 HOUR); /* == Resta 24 horas a la fecha actual == */
 select DATE_SUB(Curdate(),INTERVAL '7-2' YEAR_MONTH); /* == Resta 7 años dos meses a la fecha actual == */
====


* Restar dos fechas

====
 SELECT DATEDIFF(Curdate(),'2014-11-02'); /* == cuantos días han pasado == */
 SELECT DATEDIFF(Curdate(),'2025-09-21'); /* == Cuantos días faltan == */
====


=== Ejemplo 1

Maximos (o mínimos)

¿Cuál es el mes que hay más cumpleaños en el grupo de estudio de la cursada?

* Obtenemos por mes, cuantos cumplen años

image::2023-10-20T23-58-09-225Z.png[] 

* Tenemos que centrar en la segunda columna y buscar el valor máximo. Lo primero que hacemos es renombrar la columna del contador para usarla en la función max( )  y renombrar la consulta como una tabla.

image::2023-10-20T23-59-14-857Z.png[] 

* Proyectamos el mes de las filas agrupadas por mes y le colocamos la condición al grupo, por eso usamos el  having,  esta condición se refiere al contador. Y como vemos en la gráfica ese contador debe coincidir con el máximo que es 4

image::2023-10-20T23-59-59-441Z.png[] 

* Se debe reemplazar ese valor por la consulta que permitió calcularlo

image::2023-10-21T00-00-25-144Z.png[] 

=== Ejemplo 2

Mostrar por presupuesto el costo de mano de obra de cada reparación. Puede ocurrir que un presupuesto requiera de un arreglo que no utilice repuestos

Modelo de datos par ejemplos

image::2023-10-22T16-50-36-065Z.png[] 

* Cálculo de costo de repuestos por presupuesto

image::2023-10-22T18-18-14-726Z.png[] 

* Cálculo del monto de cada presupuesto

image::2023-10-22T18-18-38-138Z.png[] 

* Cálculo del costo de mano de obra por presupuesto

image::2023-10-22T18-20-02-709Z.png[] 

* Al usar left outer join   la columna “Costo_Rep” puede ser  null,   entonces colocamos la función  if.

image::2023-10-22T18-20-51-293Z.png[] 

Mi query

====
 select p.NPresup, p.Monto as total, p.monto - if(monto_repuesto is null, 0, monto_repuesto), monto_repuesto as  monto_mano_obra
    from presup p left outer join (
        select pr.NPresup, sum((pr.cant * r.precio)) as monto_repuesto
            from presurep pr inner join repuesto r on pr.codRep=r.codRep
            group by pr.NPresup
    ) t on p.NPresup=t.NPresup
====


