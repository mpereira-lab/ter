:stylesheet: daro-dark.css
:toc: left
:toclevels: 4
:imagesdir: ./images
:toc-title: Programación
:stem: 

= PROG

== Semana 1

=== ALgoritmo: 
** Definición: secuencia de instrucciones ordenadas, definidas y finitas para realizar una tarea
** Definición: conjunto finito de reglas que suministra una secuencia ordenada de acciones basicas con el proposito de resolver un tipo especifico de problemas

** Característica 1: nos permiten obtener resultados sin saber lo que estamos haciendo
** Característica 2: Nos permiten comunicar tareas complejas sin explicar el porque
** Característica 3: solución para automatizar tareas

* Programacion
** Definicion : arte de convertir las cosas que hacemos en secuencia de instrucciones que el computador puede realizar (en un algoritmo de computador)

=== Reglas de un algoritmo

. Debe finalizar luego de una cantidad finita de pasos
. Cada paso debe estar perfectamente definido
. Puede tener datos o no de entrada
. Debe tener uno o mas datos de salida
. Debe ser efectivo: cada uno de los pasos debe ser ejecutado con precision en un tiempo finito

=== Características de algoritmos:

. Eficacia: las oepraciones deben ser sencillas para poder ser realizadas en *forma exacta* y en *tiempo finito* por el procesador
. Caracter finito: debe tener inicio, cantidad de pasos finitos y un fin
. Precision: operaciones claras en cada paso
. Entrada: puede tener cero o mas entradas: (datos)
. Salida: una o mas salidas, que tienen relacion con los datos de entrada

=== Represenentacion de algoritmos

. Diagramas de flujo: Representación gráfica de algoritmos con símbolos y flechas regidos por ISO
. Pseudocódigo: forma escrita de un algoritmo de forma que cualquier persona lo entienda
. Sistemas formales: 
. Variables
. Estructuras secuenciales

Informatica: acronimo de information y automatique: procesamiento automatica de la informacion

=== Importanacia de algoritomos:

. Permite crear soluciones (programas) a problemas planteados inicialmente
. Sin algoritmo no hay programa. Si no hay programa, no hay nada que ejecutar
. El algoritmo se puede implementar en diferentes lenguajes de programacion y en ejecutarse en diferentes computadoras, pero el algoritmo siempre es el mismo
. Base para desarrollo de aplicaciones
. Columna vertebral para llevar a cabo la programacion por medio de perifericos que ayuden a su ejecucion

=== Programa

* Definicion: conjunto de instrucciones capaces de ser ejecutadas (obedecidas) por un computador de forma tal que realice una determinada tarea en un tiempo finito

* Definicion: resultado de una acción compuesta que fue desmenuzada en acciones elementales para que pueda ser ejecutada por el computador

=== Programacion

* Definicion: disciplina que tiene como objetivo la resolucion de problemas mediante la codigicacion de pasos para llegar a la solucion. La codificacion debe ser interpretada por la pc

=== Metodologia de 4 etapas para resolución de problemas

. Formulacion o enunciacion
. Eleccion de algoritmo
. Codificación
. Ejecución

=== Pasos dentro de ciclo de vida de cosntruccion de programa

* Paso1 diagramacion: construccion de diagrama que muestre secuencia logica de pasoso a seguir

==== 4 Fases de diagramacion
. Enunciacion del problema y necesidades
. Analisis del problema
. Obtencion del algoritmo que resuelva el problema y representarlo en diagrama
. diseño

* Paso 2. codificacion: traducir el diagrama en un lenguaje de programacion, de forma que pueda ser traducido por el compilador y ejecutado por el procesador

=== Definiciones:

* Programa fuente: codificacion del programa en un determinado lenguaje
* Compilador : 
** Verifica la sintaxis
** Traduce a lenguaje binario (lenguaje maquina)
* Proceso: tarea que realiza la computadora al ejecutar el programa

Flujo de control: acciones de programas que determinan que camino a seguir

Sentencia: cada instruccion que se le da al programa

=== Estructuras basicas de programacion estructurada

. Secuencia de sentencias
. Bifurcacion condicional simple y multiple
. Ciclo o iteracion

=== Datos y variables

Tipos de datos:

* Simples: atómicos
** Enteros: numeros + y - 
** Real: numeros + y - con decimales
** Cadena: cadena de caracteres
** Lógicos: booleano
* Compuestos: compuesto por conjunto de datos simples o de otros datos compuestos

==== Dato

Definicion: representacion simbolica de cosas, pero que no tiene conexto

Informacion: grupo de datos supervisados, procesados y ordenados

==== Variable

Es un contenedor de datos, pero puede ir variando su contenido

Cada variable tie un tipo de dato

Las variables se declaran para que el programa sepa a partir de donde existe, se le da un nombre y un tipo de dato

 Definir cantidadDeAmigos como Entero

* Nombre de variable: debe ser descriptivo
* convencion Camelcase: primera letra minuscula, cada palabra empuieza con mayuscula "estoEsUnaVariable"
* convenciones de codificación: objetivos son coherencia y la legibilidad del codigo
** dan apariencia coherente al codigo
** Permiten comprender codigo rapidamente basados en las convenciones
** Facilitan copia, cambio y mantenimiento del codigo

*Restricciones y caracteristicas de los nombres*

* no comienzan con nro
* pueden contener nros
* comienza con minuscucla
* no utilizar verbos
* solo caracteres a-z A-Z 0-9 y _
* singular

*Asignacion*: se utuliza la sentencia de asignacion

 cantidadDeAmigos =  2

==== Constante

 Definicion: valor que se define antes de ejecucion y su valor nunca cambia

==== Resolucion de problemas mediante formulación de algoritmo

* Para revolver un problema, su enunciado debe ser claro y preciso
* La reingenieria de un algoritmo es el proceso de replantearlo ya sea porque es ineficiente o ineficaz

==== Que es necesario tener en cuenta para resolver un problema usando un algoritmo

[ditaa]
....

+------------------+
| Datos de entrada | (Datos conocidos)
+------------------+
        |
        |              +------------------------------+
        |------------->| Vinculacion datos de entrada | (Conjunto de condiciones que vinculan a los conjuntos de datos anteriores)
                       +------------------------------+
                                        |
                                        |                +------------------+
                                        |--------------->| Datos de salida  | (Datos desconocidos)
                                                         +------------------+
....

==== Top Down

Consiste en dividir un problema en subproblemas, y estos otra vez en otros sub problemas para que estos se conviertan en problemas sencillos y fáciles de manejar.

Ventajas: 

. Legibilidad: es mas facil de entender lo que quiso hacer la persona que diseño el problema
. Productividad: los sub problemas se pueden divividir entre varias personas y asi resolver en forma mas rápida

==== Metodología Top Down: programación modular

Todas estas consideraciones se acercan a la idea de programación modular.

[square]
* Cada problema debe descomponerse en una serie de problemas más pequeños hasta llegar a un nivel en que cada uno de ellos no pueda reducirse más. 
* En ese momento se ha llegado al nivel más bajo del análisis.
* Es entonces cuando realmente se puede resolver el problema planteado al principio. 
* Cada uno de estos problemas de orden superior puede usar, para su resolución, problemas mínimos, comunes a varios niveles.
* Una vez demostrada la necesidad de descomponer un problema general en problemas mínimos, resulta obvio que estos no son sino los módulos de que consta el problema. 

De esa forma se realiza una programación modular y programación estructurada: el software obtenido es modular.

==== Metodología bottom up

* La metodología Bottom-up hace énfasis en la programación y pruebas tempranas, que pueden comenzar tan pronto se ha especificado el primer módulo. Este enfoque tiene el riesgo de programar cosas sin saber, cómo se van a conectar al resto del sistema, y esta conexión puede no ser tan fácil como se creyó al comienzo. La reutilización del código es uno de los mayores beneficios del enfoque bottom-up.


==== Pseudocódigo

Permite:

* Utilizar un lenguaje común a todos los programadores.
* Lograr un nivel de abstracción cuando se realizan programas.
* Facilitar la traducción de las instrucciones a un lenguaje de programación.

==== Enunciado del problema

Lo primero que me debo preguntar es si “alcanza con el enunciado para vislumbrar la solución”.

Para plantear la solución de un problema primero debo analizar el enunciado del problema, y en caso de hacer falta, puedo mencionar ciertos puntos que aclaren los datos que creo pueden faltar. De esta manera “completo” el enunciado para poder encarar la propuesta de una solución.

Entonces, se definen hipótesis cuando los datos del enunciado no son suficientes para la resolución del problema.

También me debo preguntar ¿Qué datos tengo?

==== Pasos de la solución

Se trata de una enumeración detallada y ordenada de los pasos a seguir para resolver un problema.

Es importante también que la información proporcionada en el enunciado del problema cumpla con la regla de las “Tres Ce” (Claro, Conciso y Completo).


== Semana 2

=== Diagramas de flujo

Es la representación gráfica de un algoritmo o proceso. Utilizan símbolos con significados definidos que representan los pasos del algoritmo, y representan el flujo de ejecución mediante flechas que conectan los puntos de inicio y de fin del proceso.

* Siempre el diagrama comienza con un símbolo de caja de bordes redondeados que contiene el nombre de nuestro algoritmo
* Caja con forma rectangular: se escribe un paso (nunca más de uno) del proceso del algoritmo que implica una acción
* Se escribe un paso (nunca más de uno) del proceso del algoritmo que implica una acción
* Cuando llegamos al último paso y termina el proceso del algoritmo, se indica con el símbolo de caja de bordes redondeados con las palabras Fin del algoritmo.

=== Variables

Son porciones de memoria a las que definimos con un determinado tipo de dato según el valor que necesitemos que almacene y poder  guardar en ellas datos o información.

Las operaciones se clasifican en

. Aritmética: Se componen de operandos y operadores de tipo aritmético, siendo los más habituales suma (+), resta (-), multiplicación (*), división (/) y resto de la división (%).
. Lógicas: Son aquellas que tienen como resultado verdadero o falso. Los operadores que permiten construirlas son los relacionales y los booleanos
. Cadena de caracteres: 

== Semana 3

=== Estructura secuencial


Un programa informático es una estructura que comprende una secuencia de acciones (instrucciones o comandos) y que manipula un conjunto de objetos (datos e información). 

Existen dos partes o bloques de la estructura que compone un programa:

. Bloque de declaraciones: en este se detallan todos los objetos que utiliza el programa (constantes, variables, archivos, etc.).
. Bloque de instrucciones: conjunto de acciones u operaciones que se han de llevar a cabo para conseguir los resultados esperados.

El bloque de instrucciones 

Está compuesto a su vez por tres partes, aunque en ocasiones no están perfectamente delimitadas, y aparecen entremezcladas en la secuencia del programa, podemos localizarlas según su función. Estas son:

. Entrada de datos: instrucciones que almacenan en la memoria interna datos procedentes de un dispositivo externo.
. Proceso o algoritmo: instrucciones que modifican los objetos de entrada y, en ocasiones, creando otros nuevos.
. Salida de resultados: conjunto de instrucciones que toman los datos finales de la memoria interna y los envían a los dispositivos externos.


=== Estructura de decision

a mayor parte de la potencia del procesador proviene de la capacidad de cálculo, o sea de la capacidad de tomar decisiones y determinar qué acción tomar en el momento de la ejecución del algoritmo. La estructura de decisión consta de realizar una o una serie de acciones entre un conjunto de alternativas. 

image:2023-08-31T00-30-27-225Z.png[] 

Ejemplo

image::2023-08-31T00-39-00-376Z.png[] 

=== Estructura de decisión multiple

image::2023-08-31T00-40-35-983Z.png[] 

image::2023-08-31T00-41-03-418Z.png[] 

== Semana 4

=== Estructuras de repetición

Son estructuras donde una o un conjunto de órdenes o sentencias deben cumplirse más de una vez.

* Ciclo exacto: Tomando un rango de valores inicial - final, se repite el ciclo Para cada valor intermedio dentro de ese rango elegido

* Ciclos condicionales:
** Mientras se cumpla la condición hacer (MIENTRAS – HACER).
** Hacer al menos una vez y repetir mientras se cumpla la condición (HACER – MIENTRAS).

=== Estructura de repetición PARA

image::2023-09-10T02-00-15-681Z.png[] 

image::2023-09-10T02-00-57-932Z.png[] 



=== Estructura de repetición (mientras - hacer)

image::2023-09-10T02-03-22-255Z.png[] 

image::2023-09-10T02-03-33-722Z.png[] 

=== Estructura de repetición (hacer - mientras)

image::2023-09-10T02-04-55-030Z.png[] 

image::2023-09-10T02-05-05-217Z.png[] 

== Semana 5

*Contadores y acumuladores*

=== Contador

* Siempre tienen un valor inicial.
* Su valor nuevo es el resultado del valor anterior más una constante (en nuestro ejemplo: 1).
* pueden tener cambios de forma ascendente, o disminuir desde un valor inicial.

Ejemplo:

image::2023-09-24T23-51-47-127Z.png[] 

=== Acumulador

* es una versión ampliada de un contador y tiene las mismas características que un contador excepto el valor de incremento que es un valor variable
* en el acumulador no siempre se añade un valor positivo


Ejemplo:

image::2023-09-24T23-57-05-103Z.png[] 

=== Seguimiento y depuración de algoritmos

La codificación es la operación de escribir la solución del problema (de acuerdo a la lógica del diagrama de flujo o pseudocódigo), en una serie de instrucciones detalladas en un código reconocible por la computadora, la serie de instrucciones detalladas se le conoce como programa fuente, el cual se escribe en un lenguaje de programación o lenguaje alto nivel.


==== Prueba y depuración

Resulta conveniente observar los siguientes principios al realizar una depuración, ya que de este trabajo depende el éxito de nuestra solución.


a) Tratar de iniciar la prueba de un programa con una mentalidad saboteadora, casi disfrutando la tarea de encontrar algún error.

b) Sospechar de todos los resultados que le arroje la solución, con lo cual deberá verificar todos.

c) Considerar todas las situaciones posibles normales y aún algunas de las anormales.

==== Verificación de algoritmos, ¿Que és?

Nos referimos a la comprobación del correcto funcionamiento del pseudocódigo planteado. 

Es posible que al realizar la verificación del programa o partes del programa descubramos defectos que nos obliguen a volver a la parte de desarrollo. Las verificaciones, aunque tienen momentos principales, también es habitual que se extiendan a lo largo de las fases de desarrollo, programación y mejora.

==== Tipos de errores

* Errores de compilación: Se producen normalmente por un uso incorrecto de las reglas del lenguaje de programación y suelen ser errores de sintaxis. Si existe un error de sintaxis, la computadora no puede comprender la instrucción, no se obtendrá el programa objeto y el compilador imprimirá una lista de todos los errores encontrados durante la compilación.
* Errores de ejecución: Estos errores se producen por instrucciones que la computadora puede comprender pero no ejecutar. Ejemplos típicos son: división entre cero y raíces cuadradas de números negativos. En estos casos se detiene la ejecución del programa y se imprime un mensaje de error.
* Errores lógicos: Se producen en la lógica del programa y la fuente del error suele ser el diseño del algoritmo. Estos errores son los más difíciles de detectar, ya que el programa puede funcionar y no producir errores de compilación ni de ejecución, y sólo puede advertirse el error por la obtención de resultados incorrectos o no deseados. En este caso se debe volver a la fase de diseño del algoritmo, modificar el algoritmo, cambiar el programa fuente y compilar y ejecutar una vez más.

=== Documentación
Es la guía o comunicación escrita en sus variadas formas, ya sean en enunciados, procedimientos, dibujos o diagramas. A menudo un programa escrito por una persona, es usado por muchas otras. 


Por ello la documentación sirve para ayudar a comprender o usar un programa o para facilitar futuras modificaciones por parte de los programadores (mantenimiento). Debe presentarse en tres formas con respecto al programa, en forma externa, dentro del programa de manera interna y al usuario final. 

* usuario final: 
** Descripción del problema
** Nombre del autor
** Diagrama de flujo y/o pseudocódigo
** Lista de variables y constantes
** Codificación del programa
* Documentación externa: Incluye los aspectos técnicos del programa. 
* Documentación interna: Constituyen los comentarios o mensajes que agregan al código, para hacer más claro el entendimiento del proceso. A la documentación para el usuario se le conoce como manual del usuario. En este manual no existe información de tipo técnico, sino la descripción del funcionamiento del programa.

En resumen, si en su momento dijimos que aprender a desarrollar algoritmos eficientes es aprender a programar, diremos ahora que aprender a verificar algoritmos es aprender a verificar programas. 

=== Prueba de escritorio para validar algoritmos.

Es una herramienta útil para comprender cómo funciona una estructura, ya que nos permite ver y validar cómo funciona un algoritmo que diseñamos y buscar posibles errores.
Son simulaciones del comportamiento de un algoritmo que permiten determinar la validez del mismo.

Consisten en: generar una tabla con tantas columnas como variables tenga nuestro algoritmo y 
seguir las sentencias o instrucciones de nuestro algoritmo completando los valores correspondientes a medida que se van modificando.

Con esto podemos detectar:

* errores en tiempo de ejecución, 
* errores de lógica, 
* o bien para mejorar el algoritmo pensado.

Para poder llevar a cabo las pruebas de escritorio, haremos previamente casos de prueba o lotes de prueba, estas son posibles situaciones de datos de entrada que tendrá que resolver nuestro programa y conocer con qué valor o resultado debe finalizar. 

Por ejemplo, si tuviésemos que desarrollar un algoritmo en el cual se le pida al usuario ingresar 2 números enteros y obtener el resultado de dividir el primer número ingresado por el segundo,

Un posible lote de prueba sería:

----
numeroIngresado1: 20
numeroIngresado2: 5
Resultado esperado: 4
----

Otro posible lote de prueba sería:

----
numeroIngresado1: 10
numeroIngresado2: 4 
Resultado esperado: 2.5
----

Siempre es recomendable considerar distintos escenarios como para testear nuestro algoritmo y ver cómo se comporta.

Una vez que tenemos los lotes de prueba, empezaremos a realizar la prueba de escritorio y para ello dijimos que vamos a colocar en una tabla las variables que tenga nuestro algoritmo.

==== Ejemplo de prueba de escritorio

Nuestro algoritmo es el siguiente:

image::2023-09-25T00-30-14-264Z.png[] 

La tabla para la prueba de escritorio quedaría:

image:2023-09-25T00-30-21-887Z.png[] 

Y seguimos las instrucciones exactamente como nos indica nuestro algoritmo y vamos completando una nueva fila por cada sentencia que se va ejecutando.


Recordemos nuestro primer lote de prueba:
----
numeroIngresado1: 20
numeroIngresado2: 5
Resultado esperado: 4
----

* La primer sentencia del algoritmos es: escribir “Ingresar el primer numero" quedando nuestra tabla:

image::2023-09-25T00-31-34-883Z.png[] 

* La siguiente sentencia es leer desde el teclado un número que ingrese el usuario y se almacenará en la variable numeroIngresado1 quedando nuestra tabla:

image::2023-09-25T00-31-48-413Z.png[] 

* Luego, el algoritmo solicita un segundo número y se ingresará en la variable numeroIngresado2 quedando la tabla de la siguiente manera:

image::2023-09-25T00-32-13-889Z.png[] 

* Luego, la variable resultado recibe el resultado de realizar la división de numeroIngresado1 con numeroIngresado2, con lo cual recibe el valor 4.

image:2023-09-25T00-32-37-655Z.png[] 

Y por último, se muestran por pantalla los valores de las variables:

image:2023-09-25T00-32-54-773Z.png[] 

Se recomienda hacer lotes de prueba con 1 o más casos extremos. Entendemos por casos extremos situaciones que casi nunca podrían suceder pero debemos asegurarnos que nuestro algoritmo las controle.

En nuestro algoritmo, un caso extremo sería el siguiente.

Lote de prueba  - caso extremo:

----
numeroIngresado1: 20
numeroIngresado2: 0
----

Ese lote de prueba generará un error en tiempo de ejecución ya que no se puede dividir por cero.

image::2023-09-25T00-33-34-918Z.png[] 

Lo que debemos hacer en caso de detectar errores, 

* es modificar nuestro algoritmo para solucionar el inconveniente y luego,
* realizar una nueva prueba de escritorio.

El algoritmo contemplando división por cero queda:

image::2023-09-25T00-34-10-552Z.png[] 



== Semana 6

=== Máximos y mínimos

* El máximo es el mayor valor dentro de un grupo de números. Es decir, teniendo un conjunto C, y un elemento x que pertenece a él (x ∈ C), x es el elemento máximo de C si cualquier otro elemento de dicho conjunto es menor o igual a x.
* El mínimo es el menor valor dentro de un grupo de números. Es decir, teniendo un conjunto C y un elemento x que pertenece a él (x ∈ C), x es el elemento mínimo de C si cualquier otro elemento de dicho conjunto es mayor o igual a x.

== Semana 9 Arreglos

=== Definición: 

* Es un conjunto de variables del mismo tipo que pueden ser referenciadas a través de un mismo nombre. 
* Estas variables se almacenan en posiciones contiguas de memoria. 
* La forma de identificar a un elemento determinado es a través de un índice en dónde la dirección más baja corresponde al primer elemento y la más alta al último, es decir que el índice especifica la posición relativa de la celda dentro del arreglo.
* Un arreglo es una colección finita, homogénea y ordenada de elementos. 
** Finita: todo arreglo tiene un límite
** Homogénea: todos los elementos del arreglo deben ser del mismo tipo. 
** Ordenada: existe una relación de orden; se puede determinar cuál es el primer elemento, el segundo, el tercero y el n-ésimo elemento. 
*Un arreglo puede tener una o varias dimensiones. 
** Los arreglos unidimensionales también se denominan vectores 
** los bidimensionales, matrices.

=== Vector

Es un conjunto de “contenedores” o variables llamadas celdas. Toda esta estructura tendrá un nombre que la identifique. Esto significa que cada una de las variables se llama igual. Su nombre es el mismo que el del vector, pero se diferencian mediante una segunda identificación, en este caso numérica, llamada índice.

image::2023-10-19T22-16-59-638Z.png[] 

=== Características

* todos los elementos del array son del mismo tipo
* tienen una estructura secuencial, cada elemento se ubica en una posición a la que se accede por un índice
* el índice de la primera posición es siempre 0
* el índice se incrementa de uno en uno
* su tamaño es estático, no se puede agrandar ni reducir.

image::2023-10-19T22-19-18-349Z.png[] 

=== Ejemplo


 temperaturas[ 0 ] = 28.6 
 temperaturas[ 1 ] = 26.1 
 temperaturas[ 2 ] = 25.7 
 temperaturas[ 3 ] = 26.3 
 temperaturas[ 4 ] = 27.8 
 temperaturas[ 5 ] = 28.9 
 temperaturas[ 6 ] = 25.4

image::2023-10-19T22-22-49-285Z.png[] 

=== Pseint

 Definir articulos como Entero
 Dimension articulos[200]

o

 Definir cantidad_articulos como Entero
 Definir articulos como Entero
 Dimension articulos[cantidad_articulos]

=== Notas

El lenguaje NO realiza comprobación de contornos en los arreglos; es decir, no verifica que el índice con el que accedemos a los elementos de un arreglo tenga un valor comprendido entre cero (0) y la cantidad máxima de elementos del arreglo menos 1 (por ejemplo TOPE-1).

En el caso de que sobrepase el final durante una operación de asignación, entonces se asignarán valores a otra variable o a un trozo del código o lo que se encuentre en memoria en ese momento en ese lugar que no lo habíamos reservado para nuestro arreglo. Esto es, si se dimensiona un arreglo de tamaño TOPE, permite referenciar el arreglo por encima de TOPE sin emitir ningún mensaje de error en tiempo de compilación, aunque probablemente se provoque el fallo del programa en tiempo de ejecución.



